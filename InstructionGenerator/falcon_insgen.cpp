/*

Instruction Generator
Author: Dipal Saluja

Edited on: 25 April 2018
Author: Shail Dave

Last Edited: 11 January 2021
Author: Mahesh Balasubramanian

Last edited: 3 April 2022
Author: Vinh TA

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Overview~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This module is responsible for generating the actual instructions that will be executed on the CGRA. It reads the dfgâ€™s generated by LLVM and mapping, analyzes them and generates instructions and configuration for the CGRA.

Input: FINALNODEFILE EDGEFILE LLVMNODEFILE LLVMEDGEFILE OBJFILE PrologFile KernelFile EpilogFile X Y, where objfile is the statically compiled binary, X and Y are the CGRA configs

Output: config file, prolog, epilog and kernel

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~How it works~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Instruction Encoding / Decoding for regular instruction format (R-Type)
34 33 32 | 31	30	29 28|	27   |	26	25	24|	23	22	21|	20	19|	18	17|	16	15|	14|	13 | 12  | 11 10	9	8	7	6	5	4	3	2	1	0 |
Datatype | OpCode       |Predict|	   LMUX   |    RMUX   |   R1  |	  R2  |   RW  |	WE| AB |	DB |			Immediate          	  |        /write comparison result to controller

P-Type Instruction Encoding / Decoding
34 33 32 | 31	30	29 28|	27   |	26	25	24|	23	22	21|	20	19|	18 17 |	16 15	| 14 13 12 | 11 10	9	8	7	6	5	4	3	2	1	0 |
Datatype | OpCode      |  1    |	   LMUX   |    RMUX   |   R1  |	  R2  |   RP  |   PMUX 	 |			Immediate						  |

The constructor for a CGRA instruction is as follows

CGRA_Instruction(OPCode opc,int predic,PEInputMux LMuxSel,PEInputMux RMuxSel,
int RRegAdd1,int RRegAdd2, int WAdd, bool WE, int ImmVal, bool EDMAdd, bool DMData);


To generate any instruction we need the following information (in order of constructor parameters)
1. opcode
2. bit corresponding to P-Type format
3. Left Mux Selector
4. Right Mux Selector
5. Input Register 1 number
6. Input Register 2 number
7. Write Register number
8. Write to register enabled flag
9. Immediate Value
10. Address Bus assert flag
11. Data Bus assert flag

#################### How each field is set ########################
1. Opcode
To set the opcode we read the operation type for the node and set the opcode.
The getOpCode() function gives more insight as to how the opcodes are set

2. P-Type bit
If set, P-Type instruction format is applicable

3. Left Mux Selector
This field defines where the first input operand for this instruction will come from.
getLMuxSelector() function explains how this selection is made

4. Right Mux Selector
This field defines where the second input operand for this instruction will come from.
getRMuxSelector() function explains how this selection is made

5. Input Register 1 number
If the LMUX for this instruction is set to REGISTER, we need to find out the register number this instruction will read from.

6. Input Register 2 number
If the RMUX for this instruction is set to REGISTER, we need to find out the register number this instruction will read from.

7. Write Register Number
If this instruction writes to a register, we need to get the register number that it will write to

8. Write to register enabled flag
If this instruction writes to the register file, we need to set this flag to 1, 0 otherwise
isWriteEnabled() explains this in detail

9. Immediate Value
If any of the MUX selectors is Immediate, we use the value stored here as the operand.
getImmediate() explains this in more detail

10. Address Bus assert flag
if the instruction needs to assert the address bus, we set it to 1, 0 otherwise
isAddressBusAssert() explains it in more detail

11. Data Bus assert flag
if the instruction needs to assert the data bus, we set it to 1, 0 otherwise
isDataBusAssert() explains it in more detail

12. Datatype field
Currently we have support for int and flaoting point operations. This
is defined by the Datatype enum in CGRAdefinitions. 

~~~~~~~~~~~~~~~~~~LIST OF UTILITIES REQUIRED~~~~~~~~~~~~~~~~~
1. nodeid, operation type
2. edge, operand order
3. nodeid, name
4. nodeid, pe for kernel, prolog and epilog
5. nodeid, schedule_time for kernel, prolog, epilog
6. nodeid, generated Instruction
7. {time,pe}, node id for prolog, epilog and kernel
8. pe, number of memory operations
9. nodeid, register it writes to
10. in_edge
11. out_edge

~~~~~~~~~~~~~~~~FLOATING POINT IMMEDIATE SUPPORT~~~~~~~~~~~~~
The floating point immediates are considered as Recurring variables. So they are loaded into the non-recurring reg file during the init cycle. Each floating point immediate vaLue is a 64 bit double precision value, defined by the FLOAT union codeset in CGRAdefinition. This 64-bit floating point immediate value is then stored to the non-recurring regfile, using LDI, LDMI, and LDMI set of load registers. The floating point equivalent in then computed in gem5. 

*/

/*
   to do: Implement Memory Mode of Mapping i.e. To Generate instructions in case of using memory when out of registers
   This requires that it should be determined which nodes are corresponding store and load nodes for some value (operation)
   It should be also figured out how far such store and load (x II cycles) operations would be scheduled
   This decides number of temporary memory locations for the storage
   It also implies that in such case either memory should be rotating or kernel should be unrolled x times
   Hence, current implementation of the back-end does not support the spilling.


   to do: Implement a support for double precision floating point which requires 6 load instructions to store the 64-bit double precision number.
 */

#include <iostream>
#include <fstream>
#include <sstream>
#include <map>
#include <set>
#include <vector>
#include <string>
#include <cstring>
#include "CGRAInstruction.cpp"
#include <cstdlib>
#include <cmath>
#include <cstdio>
#include <assert.h>

using namespace std;

//map for ddgs node id and type
std::multimap< std::pair<int,int>, int > nodeid_type;

//a vector of routing nodes
std::set<int> routingNodes;

//map for ddgs node id and name
std::map<int,string> nodeid_names;

//map for ddgs node id and incoming edge's source node ids
std::multimap<int,int> in_edge;

//map for ddgs node id and outgoing edge's destination node ids
std::multimap<int,int> out_edge; 

//map for edge, operand order
std::multimap< std::pair<int,int>,int> operand_order_map;

//pred dependecy pairs
std::map<int,int> pred_pairs; 

//The final generated instruction for a node
std::map<int,CGRA_Instruction> nodeid_instruction;

//The final generated instruction for a predicate node
std::map<int,Pred_Instruction> nodeid_Predinstruction;

//array of prolog,kernel and epilog operation (in terms of node id from ddg)
int *prolog,*kernel,*epilog, *livevar_store;

//array of final decoded prolog,kernel and epilog instructions
unsigned long *final_prolog,*final_kernel,*final_epilog, *final_livevar_store;

int final_prolog_size,final_kernel_size,final_epilog_size, final_livevar_store_size, final_config_size;

//the load instructions to pre-load the nonrecurring values into registers
std::multimap<int, std::vector<Pred_Instruction> > initInstructions;

int prolog_size, kernel_size, epilog_size;

//a map of node_id,pe_num for prolog,kernel and epilog
std::map<int,int> prolog_map, kernel_map, epilog_map;

//a map for node_id, mapped time for prolog, kernel and epilog
std::map<int,int> node_time_map_prolog, node_time_map_kernel, node_time_map_epilog;

//a map for node_id, schedule time
std::map<int,int> node_schedule_time;

//a map of nodes scheduled at time
std::map<int, std::set<int> > schedule_time_nodes;

//a map for pe, freeRegisters
std::map< int, std::set<int> > pe_free_registers;

//a map for {pe,time}, registerAllocation for kernel
std::map< std::pair<int,int>, int> pe_time_Registers_map;

//a map storing the number of nonrecurring values mapped to a pe, <pe,num_mem ops>
std::map<int,int> pe_mem_op_map;
std::map<int,int> pe_mem_op_cycles_map;
std::map<int,int> pe_livein_load_map;

//a map storing the number of values into rotating registers (valid within II cycle) corresponding to a node
std::map<int,int> srcnode_rotatingreg_readonly_map;

//a map storing the number of values into rotating registers (required in different stages) corresponding to a node
std::map<int,int> srcnode_rotatingreg_map;

//a map of node_id,reg_num it writes to for kernel
std::map<int, int> node_Output_Register;

//a set of nodes that have any of the operands from the Rotating section of the RF
std::set<int> nodesThatReadRotatingRF;

//map for ddgs to_node id in the edge file (only if it is phi node) and dependency distance of edge
std::map<int,int> to_node_dependency_distance;

//map for ddgs phi node in the node file and its corresponding result (finally selected node's ID)
std::map<int,int> select_constant_node_result;
std::map<int,int> select_phi_node_result;

std::map<int,PEInputMux> lmux_phi;
std::map<int,PEInputMux> rmux_phi;
std::map<int,int> immediate_phi;

//a map for the number of times a phi node appeared into prolog
std::map<int,int> phi_prolog_counter;

//The final generated instruction for a node for prolog
std::map<int,CGRA_Instruction> nodeid_instruction_prolog;

// final generated instructions for liveout in epilog
std::map<int, CGRA_Instruction> liveout_epilog; 

//a map for (load nodes) node id and load alignment
std::map<int,unsigned> memory_access_alignment;

//CGRA configuration
int X, Y, R;

//Initiation Interval
int II;

int kernel_II;

//max number of nonrecurring values mapped to a PE
int maxMemoryOperations = 0;

//total cycles for initialization of CGRA (loading config boundary and loading live-in)
int init_cycles = 0;

//a map of nodeID, regNum for ld_add and st_add nodes. The register will hold
//the nonrecurring value such as live-in value
std::map<int,int> mem_node_regNum;
std::map<int, std::map<int,int>> mem_node_pe_regNum;  // map from constant node to pe to regnum

//data for live out variables
//map for livevariables' node index and id
std::map<int,int> livevar_node_list;

//map for liveout variables' node id and mapped pe
std::map<int,int> livevar_pe_map;

//map for liveout variables' node id and id of corresponding store node
std::map<int,int> liveout_storeop_map;

//map for livein  variables' node id and mapped pe
std::map<int,int> livein_pe_map;

//a map of nodes scheduled at time
std::map<int, std::set<int> > time_pe_map_livevar;

//a vector of constants value of which is larger than represented through immediate bits
std::set<int> largeConstants;

//a map for a larger constant's node id and variable node requiring that constant
std::map<int,std::vector<int>> const_node_map;

//a map for a pe id and pe's register configuration boundary for mixed register file
std::map<int,int> pe_reg_config;

//data for live In variables
//map for livevariables' node index and id
std::map<int,int> liveInoperand_node_list;

int earliest_sched_time = 10000;

//execution state of cgra
enum exec_state{
  state_prolog,
  state_kernel,
  state_epilog_start,
  state_epilog
};

//return the PE number given an index.
int getPE(int i)
{
  return (i%(X*Y));
}

int getTime(int i)
{
  return (i/(X*Y));
}

int getNodeType(int id)
{
  std::multimap< std::pair<int,int>, int>::iterator it;
  for(it = nodeid_type.begin(); it != nodeid_type.end(); it++)
  {
    std::pair<int,int> tempNode = it->first;

    if(tempNode.first == id)
      return it->first.second;
  }

  //should not come here.
  return -1;
}

int getNodeDataType(int id)
{
  std::multimap< std::pair<int,int>, int>::iterator it;

  for(it = nodeid_type.begin(); it != nodeid_type.end(); it++)
  {
    std::pair<int,int> tempNode = it->first;

    if(tempNode.first == id)
      return it->second; 
  }
  //should not enter here.
  return -1;
}

bool isPTypeInstruction(int id)
{
  // Find Node Type
  //std::multimap< std::pair<int,int>, int>::iterator it = nodeid_type.find(id);
  int nodeType = getNodeType(id); //it->first.second;
  bool isPType = false;

  /* Instructions for configuraing Register File boundary
     or for pre-loading live-in values is generated separately.
     So, we do not need to encode or decode them as P-type.
   */
  switch (nodeType) {
    case cond_select:
    case loopctrl:
    case sext:
      isPType = true;
      break;
    default:
      isPType = false;
  }

  return isPType;
}

string getNameFromInstr(Instruction_Operation op)
{
  switch(op)
  {
    case add: return "add"; break;
    case sub: return "sub"; break;
    case mult: return "mult"; break;
    case division: return "division"; break;
    case shiftl: return "shiftl"; break;
    case shiftr: return "shiftr"; break;
    case andop: return "andop"; break;
    case orop: return "orop"; break;
    case xorop: return "xorop"; break;
    case cmpSGT: return "cmpSGT"; break;
    case cmpEQ: return "cmpEQ"; break;
    case cmpNEQ: return "cmpNEQ"; break;
    case cmpSLT: return "cmpSLT"; break;
    case cmpSLEQ: return "cmpSLEQ"; break;
    case cmpSGEQ: return "cmpSGEQ"; break;
    case cmpUGT: return "cmpUGT"; break;
    case cmpULT: return "cmpULT"; break;
    case cmpULEQ: return "cmpULEQ"; break;
    case cmpUGEQ: return "cmpUGEQ"; break;
    case ld_add: return "ld_add"; break;
    case ld_data: return "ld_data"; break;
    case st_add: return "st_add"; break;
    case st_data: return "st_data"; break;
    case ld_add_cond: return "ld_add_cond"; break;
    case ld_data_cond: return "ld_data_cond"; break;
    case loopctrl: return "loopctrl"; break;
    case cond_select: return "cond_select"; break;
    case route: return "route"; break;
    case llvm_route: return "llvm_route"; break;
    case cgra_select: return "cgra_select"; break;
    case constant: return "constant"; break;
    case rem: return "rem"; break;
    case sext: return "sext"; break;
    case shiftr_logical: return "shiftr_logical"; break;
    case rest: return "rest"; break;
    default: return "rest"; break; 
  }

}

string getNodeName_mem(int id)
{
  if(getNodeType(id) == route)
    return "route";

  Instruction_Operation nodename; 
  //std::map<int, string>::iterator it = nodeid_names.find(id);
  std::multimap<std::pair<int, int>,int>::iterator it;// = nodeid_type.find(id);
  for(it = nodeid_type.begin(); it != nodeid_type.end(); it++)
  {
    std::pair<int,int> tempNode = it->first;
    if(tempNode.first == id)
    {
      nodename = (Instruction_Operation) tempNode.second;
      break; 
    }
  }

  string name = getNameFromInstr(nodename); 

  //return it->second;
  return name;
}

string getNodeName(int id)
{
  if(getNodeType(id) == route)
    return "route";

  std::map<int, string>::iterator it = nodeid_names.find(id);

  return it->second;
}

int getDepenDistance(int id)
{
  int retVal = -1;
  std::map<int, int>::iterator it = to_node_dependency_distance.find(id);
  if(it != to_node_dependency_distance.end())
    retVal = it->second;
  return retVal;
}

int getSelectedConstantNode(int id)
{
  std::map<int, int>::iterator it = select_constant_node_result.find(id);
  return it->second;
}

int getSelectedPhiNode(int id)
{
  std::map<int, int>::iterator it = select_phi_node_result.find(id);
  return it->second;
}

int getPhiNode(int id)
{
  int ret = -1;
  std::map<int, int>::iterator it;
  for(it = select_phi_node_result.begin(); it != select_phi_node_result.end(); ++it)
  {
    if(it->second == id)
    {
      ret = it->first;
      return ret;
      break;
    }
  }
  return ret;
}

void setlmuxphi(int id, PEInputMux result)
{
  std::map<int, PEInputMux>::iterator it = lmux_phi.find(id);
  it->second = result;
}

void setrmuxphi(int id, PEInputMux result)
{
  std::map<int, PEInputMux>::iterator it = rmux_phi.find(id);
  it->second = result;
}

void setimmediatephi(int id, long result)
{
  std::map<int, int>::iterator it = immediate_phi.find(id);
  it->second = result;
}

PEInputMux getlmuxphi(int id)
{
  std::map<int, PEInputMux>::iterator it = lmux_phi.find(id);
  return it->second;
}

PEInputMux getrmuxphi(int id)
{
  std::map<int, PEInputMux>::iterator it = rmux_phi.find(id);
  return it->second;
}

long getimmediatephi(int id)
{
  std::map<int, int>::iterator it = immediate_phi.find(id);
  return it->second;
}

int getLiveNode(int id)
{
  std::map<int, int>::iterator it = livevar_node_list.find(id);
  return it->second;
}

int getLiveVarMappedPE(int id)
{
  std::map<int, int>::iterator it = livevar_pe_map.find(id);
  if(it == livevar_pe_map.end()) _FATAL("Cannot find livevar mapped PE!\n");
  return it->second;
}

int getLiveInMappedPE(int id)
{
  std::map<int, int>::iterator it = livein_pe_map.find(id);
  return it->second;
}

bool isStoreNode(int id){
  if(getNodeType(id) == route)
    return false;

  string nodename = getNodeName_mem(id);
  if((nodename.find("st_add") != string::npos) || (nodename.find("st_data") != string::npos))
    return true;
  else return false;
}

bool isLiveStoreNode(int id)  // returns true only if LLVM dedicates a node to be liveout
{
  if(getNodeType(id) == route)
    return false;
  
  for(std::map<int,int>::iterator it = livevar_pe_map.begin(); it != livevar_pe_map.end(); ++it)
    if((*it).first == id) return true;

  return false;
}

int getLiveOutToBeStored(int node)
{
  int liveOutData = -1;
  std::map<int, int>::iterator itt;
  for(itt = liveout_storeop_map.begin(); itt != liveout_storeop_map.end(); ++itt)
  {
    if(itt->second == node)
    {
      liveOutData = itt->first;
      break;
    }
  }
  return liveOutData;
}

bool isLiveStoreData(int id)
{
  string nodename = getNodeName_mem(id);
  if(nodename.find("st_data") != string::npos)
    return true;
  else
    return false;
}

bool isLiveOutData(int id)
{
  if(liveout_storeop_map.find(id) != liveout_storeop_map.end())
    return true;
  return false;
}

int isLiveInNode(int id)
{
  if(getNodeType(id) == route)
    return 0;

  string nodename = getNodeName(id);
  if((nodename.find("ld_add") != string::npos) || (nodename.find("ld_data") != string::npos))
    return 1;
  else
    return 0;
}

//get the scheduled time of a node
int getScheduledTime(int id)
{
  return node_schedule_time[id];
}

//returns whether the operations are scheduled more than a cycle apart or not
bool isScheduledMoreThanACycleApart(int node1,int node2)
{
  bool retVal = false;
  int t1 = getScheduledTime(node1);
  int t2 = getScheduledTime(node2);
  
  // check for abs dependency.
  retVal = (abs(t1-t2) > 1);

  // check for II-1 --> 0 dependency. 
  if(abs(t1-t2) == (kernel_II-1))
    retVal = false; 

  return retVal;
}


//get the PE number where this node is mapped depending on the state of execution
int getMappedPE(int id, exec_state state)
{
  int pe=0;
  switch(state){
    case state_prolog:
      pe = (prolog_map.find(id))->second;
      break;
    case state_kernel:
      pe = (kernel_map.find(id))->second;
      break;
    case state_epilog_start:
      pe = (kernel_map.find(id))->second;
      break;
    case state_epilog:
      pe = (epilog_map.find(id))->second;
      break;
    default:
      break;
  }
  return pe;
}

//return the relative position of PE j wrt PE i
PEInputMux getRelativePosition(int i, int j)
{
  PEInputMux result = Up;
  int diff=i-j;

  if(diff == 0)
    result = Self;
  else if (diff == (1-Y) || diff == 1)
    result = Left;
  else if (diff == (Y-1) || diff == -1)
    result = Right;
  else if (diff == (Y*(1-X)) || diff == Y)
    result = Up;
  else if (diff == (Y*(X-1)) || diff == -Y)
    result = Down;

  return result;
}

//extract number from a string
unsigned long extractNumber(string name)
{
  char* str = new char[name.length()+1];
  strcpy(str,name.c_str());
  unsigned int result = 0;
  sscanf(str, "%*[^-0123456789]%d",&result);
  return result;
}

FLOAT extractFPNumber(string name)
{
  char* str = new char[name.length()+1];
  strcpy(str,name.c_str());
  FLOAT result;
  sscanf(str, "%*[^-0123456789]%f",&(result.f));
  return result;
}

unsigned long getDoublePrecision(FLOAT var)
{
  unsigned long result=0; 
  unsigned long Ins=0;
  Ins |= var.raw.sign;
  Ins <<= SHIFT_SIGN;
  Ins &= INS_SIGN;

  result |= Ins;

  Ins=0;
  Ins |= var.raw.exponent;
  Ins <<= SHIFT_EXPONENT;
  Ins &= INS_EXPONENT;

  result |= Ins;

  Ins=0;
  Ins |= var.raw.mantissa;
  Ins <<= SHIFT_MANTISSA;
  Ins &= INS_MANTISSA;

  result |= Ins;

  return result; 
}

std::vector<int> getConstantMappedPE(int id)
{
  std::vector<int> ret;
  std::map<int,std::vector<int>>::iterator it = const_node_map.find(id);
  for(std::vector<int>::iterator node_it = it->second.begin(); node_it != it->second.end(); ++node_it)
    ret.push_back(getMappedPE((*node_it), state_kernel));
  return ret;
}

bool isLargeConstant(int id)
{
  if(getNodeType(id) != constant)
    return false;

  string nodename = getNodeName(id);
  if(nodename.find("ConstInt") != string::npos)
  {
    unsigned long immediatedata = extractNumber(nodename);
    if(immediatedata > MAX_CONSTANT)
      return true;
    else
      return false;
  }
  //else if(nodename.find("ConstFP") != string::npos)
  //return true;
  else
    return true;
}

//read the symbol table from obj, get the address of var and print it
unsigned int getVariableAddress(string var,string obj)
{
  FILE *pipe;
  char result[80];
  string command;
  int addr_array[50];
  int i=0;

  command = "arm-linux-gnueabi-readelf -s ";
  command += obj + " | grep -w \"";
  command += var + "\" | tr -s ' '|cut -d' ' -f3";
  
  if (( pipe = popen(command.c_str(), "r")) == NULL)
  {
    perror("popen");
    exit(1);
  }

  fgets(result,80,pipe);
  pclose(pipe);

  unsigned int addr=(unsigned int)strtol(result,NULL,16);
  return addr;
}

unsigned long extractlimit_from_node(int node)
{
  unsigned long result;
  std::multimap<int, int>::iterator it = in_edge.find(node);
  std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
  ret = in_edge.equal_range(node);
  for (std::multimap<int,int>::iterator it2=ret.first; it2!=ret.second; ++it2)
  {
    int nodeType = getNodeType(it2->second);
    if (nodeType == constant)
    {
      std::map<int, string>::iterator nameit = nodeid_names.find(it2->second);
      result = extractNumber(nameit->second);
      break;
    }
  }
  return result;
}

std::vector<int> getOperands(int nodeID)
{
  std::vector<int> result;
  //we cant have more than 3 operands
  int temp[3] = {-1,-1,-1};

  int nodeType = getNodeType(nodeID);
  
  if(nodeType != st_data && nodeType != ld_data)
  {
    int ctr = 0, temp_operand, operand_counter=0;
    std::multimap< std::pair<int,int>,int>::iterator it;

    for(it = operand_order_map.begin(); it != operand_order_map.end(); it++)
    {
      std::pair<int,int> tempEdge = it->first;
      if(tempEdge.second != nodeID)
        continue;
      
      /*if(getNodeType(tempEdge.first) == route && temp[0] != -1){
        for(int i=operand_counter-1; i>=0; i--)
	  temp[i+1] = temp[i];  // Push added non-route nodes to the right
	
	ctr = 0;
	}*/
      
      if(it->second == 0)
	ctr = (temp[0] == -1)? 0: ((temp[1] == -1)? 1:2);
      else if(it->second == 1)
	ctr = (temp[1] == -1)? 1:2;
      else
	ctr = 2;
      
      temp[ctr] = tempEdge.first;
      operand_counter++;
    }

    if(operand_counter == 1)
      temp[0] = (temp[0] == -1)? ((temp[1] == -1)? temp[2]:temp[1]):temp[0];
    else if(operand_counter == 2)
      if(temp[0] == -1) {temp[0] = temp[1]; temp[1] = temp[2];}
      else if(temp[1] == -1) temp[1] = temp[2];
      
    for(int j =0;j<operand_counter;j++)
      result.push_back(temp[j]);
  }
  else
  {
    std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
    ret = in_edge.equal_range(nodeID);
    for (std::multimap<int,int>::iterator it=ret.first; it!=ret.second; ++it)
    {
      result.push_back(it->second);
    }
  }
  return result;
}

std::vector<int> getOperandsPred(int nodeID)
{
  std::vector<int> result;
  //we cant have more than 3 operands
  int temp[3];
  int select_signal;
  int nodeType = getNodeType(nodeID);
  if(nodeType != st_data && nodeType != ld_data)
  {
    int ctr = 0, temp_operand, operand_counter=0;
    std::multimap< std::pair<int,int>,int>::iterator it;
    for(it = operand_order_map.begin(); it != operand_order_map.end(); it++)
    {
      std::pair<int,int> tempEdge = it->first;
      if(tempEdge.second != nodeID)
        continue;

      ctr = it->second; 
      temp[ctr] = tempEdge.first;
      operand_counter++;
    } 

    for(int j =0;j<operand_counter;j++)
    {
      std::map<int, int>::iterator predit = pred_pairs.find(temp[j]);

      for(predit = pred_pairs.begin(); predit != pred_pairs.end(); predit++)
        select_signal = predit->first;       
    }
    for(int j =0;j<operand_counter;j++)
    {
      if(temp[j] == select_signal)
        continue;

      result.push_back(temp[j]);
    }
    result.push_back(select_signal);  
  }
  else
  {
    std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
    ret = in_edge.equal_range(nodeID);
    for (std::multimap<int,int>::iterator it=ret.first; it!=ret.second; ++it)
    {
      result.push_back(it->second);
    }
  }
  return result;
}

//get the mapped time of this node depending on the execution state
int getMappedTime(int id, exec_state state)
{
  int t=0;
  if(isStoreNode(id))
  {
    //Currently We Assume That This Function Will Be Required To Be Called By Store_Data;
    //Possibility of Store_Add is To Be Checked
    int node_sched_time = node_schedule_time[id];
    string nodename = getNodeName(id);
    if((nodename.find("st_data") != string::npos))
    {
      int op;
      vector<int> operands = getOperands(id);
      for(int i=0;i<operands.size();++i)
      {
        int type = getNodeType(operands[i]);
        if(type!=constant && type!=st_add)
        {
          op = operands[i];
          break;
        }
      }
      int op_sched_time = node_schedule_time[op];
      int op_map_time = getMappedTime(op,state);
      t = op_map_time + (node_sched_time - op_sched_time);
      t = (t % kernel_II);
    }
  }
  else
  {
    switch(state){
      case state_prolog:
        t = (node_time_map_prolog.find(id))->second;
        break;
      case state_kernel:
        t = (node_time_map_kernel.find(id))->second;
        break;
      case state_epilog_start:
        t = (node_time_map_kernel.find(id))->second;
        break;
      case state_epilog:
        t = (node_time_map_epilog.find(id))->second;
        break;
      default:
        break;
    }
  }
  t = (t % kernel_II);
  return t;
}

//returns whether the operations are mapped more than a cycle apart or not
// sign variable is for the loop carried dependecies especially when it is from the previous cycle.
bool isMappedMoreThanACycleApart(int node1,int node2,exec_state state, int II)
{
  bool retVal = false;
  int t1 = getMappedTime(node1,state);
  int t2 = getMappedTime(node2,state);

  unsigned diff = abs(t1-t2);
  int sign = t1-t2;

  if((t2==0) && (t1==II-1))
    diff=0;

  if(sign < 0)
    retVal = (diff > 1);
  else
    if(diff > 0)
      retVal = true; 

  return retVal;
}

int getLiveVarData(int nodeID)
{
  //get Operands of LiveVar St_Data Node
  std::vector<int> operands = getOperands(nodeID);
  int st_add = nodeID - 1;
  int livevar_data;
  /*
   * We first search that whether the st_add has any operands.
   * If yes, then st_data should have one operand has st_add and other as node providing live data value
   * Else, We see that which operand is either constant/phi node and choose it as address node and choose remaining operand as data node providing live var.
   */
  for(std::vector<int>::iterator it = operands.begin(); it!= operands.end(); ++it)
  {
    string nodename = getNodeName(*it);
    if(((getNodeType(*it) != st_add) && (getNodeType(*it) != constant)) || (nodename.find("Const") != string::npos))
      livevar_data = *it;
  }

  return livevar_data;
}

//get the node id for the source operation of this routing node
int getRouteSrc(int id)
{
  std::multimap<int, int>::iterator it = in_edge.find(id);
  if(getNodeType(it->second) != route)
    return it->second;
  else
    return getRouteSrc(it->second);
}

// Vinh TA:
// With move to 64-bit, LDi can be done with 1 inst for int32 dt
void storeNonRecurringVal(unsigned int addr_array, int reg_num, int pe)
{
  unsigned long LDi_imm = addr_array & 0xffffffff;
  //unsigned long LDMi_imm = (addr_array & 0x00fff000) >> 12;
  //unsigned long LDUi_imm = (addr_array & 0xff000000) >> 24;

  Datatype dt = int32; 

  Pred_Instruction LDi_ins (dt, LDi, Immediate,Register,(PEInputMux) 4,0,0,reg_num,LDi_imm); //4 for writing value in reg.
  //Pred_Instruction LDMi_ins(dt, LDMi,Immediate,Register,(PEInputMux) 4,0,0,reg_num,LDMi_imm);
  //Pred_Instruction LDUi_ins(dt, LDUi,Immediate,Register,(PEInputMux) 4,0,0,reg_num,LDUi_imm);

  unsigned long dec1 = LDi_ins.DecodePredInstruction(&LDi_ins);

  printf("StoreNonRecurringVal: decoded inst: %lx\n", dec1);
  //unsigned long dec2 = LDMi_ins.DecodePredInstruction(&LDMi_ins);
  //unsigned long dec3 = LDUi_ins.DecodePredInstruction(&LDUi_ins);

  std::vector<Pred_Instruction> ins_set;
  ins_set.push_back(LDi_ins);
  //ins_set.push_back(LDMi_ins);
  //ins_set.push_back(LDUi_ins); 

  initInstructions.insert(std::pair<int,std::vector<Pred_Instruction> >(pe,ins_set));
}

// Vinh TA:
// For float32/16 dt, LDi can be done in 1 cycle
// For float64 dt, LDi can be done in 2 cycles
// TODO: float64 is not yet supported (Apr 22) due to RF config
void storeNonRecurringFPVal(unsigned int addr_array, int reg_num, int pe)
{
  unsigned long LDi_imm = addr_array & 0xffffffff;
  //unsigned long LDMi_imm = (addr_array & 0x00fff000) >> 12;
  //unsigned long LDUi_imm = (addr_array & 0xff000000) >> 24;

  Datatype dt = float32;

  Pred_Instruction LDi_ins (dt, LDi, Immediate,Register,(PEInputMux) 4,0,0,reg_num,LDi_imm); //4 for writing value in reg.
  //Pred_Instruction LDMi_ins(dt, LDMi,Immediate,Register,(PEInputMux) 4,0,0,reg_num,LDMi_imm);
  //Pred_Instruction LDUi_ins(dt, LDUi,Immediate,Register,(PEInputMux) 4,0,0,reg_num,LDUi_imm);

  unsigned long dec1 = LDi_ins.DecodePredInstruction(&LDi_ins);

  printf("storeNonRecurringFPVal: decoded inst: %lx\n", dec1);
  //unsigned long dec2 = LDMi_ins.DecodePredInstruction(&LDMi_ins);
  //unsigned long dec3 = LDUi_ins.DecodePredInstruction(&LDUi_ins);

  std::vector<Pred_Instruction> ins_set;
  ins_set.push_back(LDi_ins);
  //ins_set.push_back(LDMi_ins);
  //ins_set.push_back(LDUi_ins);

  initInstructions.insert(std::pair<int,std::vector<Pred_Instruction> >(pe,ins_set));
}

void getArrayAddress(int pe, unsigned int addr, int node, int reg_num, int maxMemoryOperations, int num_mem_ops)
{
  int id;
  string nodename;
  int arr_mult, arr_add;

  std::multimap<int, int>::iterator it = in_edge.find(node);
  vector<int> operands = getOperands(it->second);

  if(getNodeType(it->second) == route)
    arr_add = getRouteSrc(it->second);
  else
    arr_add = it->second;

  std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
  ret = in_edge.equal_range(arr_add);

  for (std::multimap<int,int>::iterator it2=ret.first; it2!=ret.second; ++it2)
  {
    if(getNodeType(it2->second) == route)
      arr_mult = getRouteSrc(it2->second);
    else if(getNodeType(it2->second) == constant)
      continue;
    else
    {
      arr_mult = it2->second;
      break;
    }
  }

  id = getNodeType(arr_mult);
  nodename = getNodeName(arr_mult);

  if( (id == Mult) && (nodename.find("idxprom") != string::npos) )   //getArrayAddress
  {
    int addr_array = addr;
    printf("Get Address: Array Address (Hex): %x\t",addr_array);
    cout<< "Node: " << node<<"\tPE: "<<pe<<"\tArray Address (Decimal): "<<addr_array<<"\tRegNum: "<<reg_num<< endl;
    storeNonRecurringVal(addr_array, reg_num, pe);
  }
  else
  {
    printf("Get Address: Address (Hex): %x\t",addr);
    int value;
    cout<< "Node: " << node<<"\tPE: "<<pe<<"\tArray Address (Decimal): "<<addr<<"\tRegNum: "<<reg_num<< endl;
    for (std::multimap<int,int>::iterator it2=ret.first; it2!=ret.second; ++it2)
    {
      int node_id = it2->second;

      // added this check to eliminate nodes other then mult
      if(getNodeType(node_id) != Mult)
        continue;

      std::map<int, string>::iterator nameit = nodeid_names.find(node_id);
      value = (unsigned int) extractNumber(nameit->second);
    }
    unsigned int addr_array= (unsigned int) addr+(4*value); //getElementAddress  
    storeNonRecurringVal(addr_array, reg_num, pe);
  }
}

/*
 * this function is responsible to update the operand orders by incorporating
 * the routing nodes generated by mapping technique
 */
void updateOperandOrder()
{
  /*Steps:
   * get all routing nodes.
   * for each routing node, get all the outgoing edges
   *  for each outgoing edge, get the operand order from the source of this
   *  routing node to the destination of the edge.
   *  update the operand order map with
   */
  //for(int i=0;i<routingNodes.size();++i)
  //{
   for(auto node : routingNodes)
   {	   
    int src = getRouteSrc(node);    
    std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
    ret = out_edge.equal_range(node);
    for (std::multimap<int,int>::iterator it=ret.first; it!=ret.second; ++it)
    {
      //edge from route to dest
      std::pair<int,int> edge1(node,it->second);

      //edge from src to dest
      std::pair<int,int> edge2(src,it->second);
      std::multimap<std::pair<int,int>,int>::iterator itt;
      for(itt = operand_order_map.begin(); itt != operand_order_map.end(); itt++)
      {
        if((itt->first.first != src) || (itt->first.second != it->second))
          continue;
        int operandOrder = itt->second;
        operand_order_map.insert(std::pair< std::pair<int,int>,int >(edge1,operandOrder));
      }
    }
  }
}

OPCode getOpCode(int nodeID)
{
  Instruction_Operation type = (Instruction_Operation) getNodeType(nodeID);
  OPCode opcode;
  switch(type)
  {
    case add:
      opcode = Add;
      break;
    case sub:
      opcode = Sub;
      break;
    case mult:
    case llvm_route:
      opcode = Mult;
      break;
    case division:
      opcode = Div;
      break;
    case shiftl: 
      opcode = cgraASL;
      break;
    case shiftr:
      opcode = cgraASR;
      break;
    case shiftr_logical:
      opcode = LSHR;
      break;
    case andop:
      opcode = AND;
      break;
    case orop:
    case bitcast:
      opcode = OR;
      break;
    case xorop:
      opcode = XOR;
      break;
    case cmpUGT:
    case cmpUGEQ:
    case cmpSGEQ:
    case cmpSGT:
      opcode = GT;
      break;
    case cmpEQ:
      opcode = EQ;
      break;
    case cmpNEQ:
      opcode = NEQ;
      break;
    case cmpULT:
    case cmpULEQ:
    case cmpSLEQ:
    case cmpSLT:
      opcode = LT;
      break;
    case ld_add:
    case st_add:
      opcode = (OPCode) address_generator;
      break;
    case ld_data:
    case st_data:
      opcode = Add;
      break;
    case route:
      opcode = Add;
      break;
    case cgra_select:
      opcode = (OPCode) LDi;
      break;
    case rem:
      opcode = Rem;
      break;
    case cond_select:
      opcode = (OPCode) sel;
      break;
    case loopctrl:
      opcode = (OPCode) loopexit;
      break;
    case sext:
      opcode = (OPCode) signExtend;
      break;
    default: 
      if(nodeID==5)
        cout << "In default" << endl;
      opcode=NOOP;
      break;
  }
  return opcode;
}

Datatype getDataType(int nodeID)
{
  Datatype dt;
  dt = (Datatype) getNodeDataType(nodeID);
  return dt; 
}

//returns where the 1st operand of this instruction is going to come from
PEInputMux getLMuxSelector(int nodeID, exec_state state)
{
  /*
   *************Memory Operations*******************
   if the instruction is ld_add, st_add
   result = REGISTER

   if the instruction is a ld_data
   result = DATABUS

   if the instruction is st_data
   {
   get the node id of the operand other than the varname and st_add
   if they are scheduled more than a cycle apart
   {
   result = REGISTER
   }
   else
   result = Relative PE position of the operand to the PE this node is mapped on
   }
   ***************Alu Operations**************
   Get the first operand (lets call it op)
   If(op is Constant)
   result = IMMEDIATE
   if(op is scheduled more than 1 cycle apart)
   result = REGISTER
   else
   result = Relative PE position of the operand to the PE this node is mapped on

   *****************Route Operation************
   get the nodeID of the src node in the edge in which this is the destination
   if they are scheduled more than a cycle apart
   result = REGISTER
   else
   result = Relative position of the PE of the src node to the PE this node is mapped to
   */
  
  PEInputMux result = Register;
  int nodetype = getNodeType(nodeID);
  vector<int> operands;
  
  if(isPTypeInstruction(nodeID))
    operands = getOperandsPred(nodeID);
  else
    operands = getOperands(nodeID); 

  int pe1,pe2;

  //there will be atmost 1 incoming edge to the routing node
  std::multimap<int, int>::iterator it_inedge = in_edge.find(nodeID);
  //MEMORY OPERATIONS
  switch(nodetype){
    case ld_add:
    case st_add:
      if(operands.size() == 0)
      {
        result = Immediate;
        if(isStoreNode(nodeID))
          result = Register;
        return result;
      }
      else
      {
        int operand1 = operands[0];
        int opType = getNodeType(operand1);
        if(isScheduledMoreThanACycleApart(nodeID,operand1))
        {
          nodesThatReadRotatingRF.insert(nodeID);
          result = Register;
          return result;
        }
	else if(getNodeType(operand1) == constant){
	  nodesThatReadRotatingRF.insert(nodeID);
	  result = Register;
	  return result;
	}
        else
        {
          if(isLiveStoreNode(nodeID))
            pe1 = getLiveVarMappedPE(nodeID);
          else
            pe1 = getMappedPE(nodeID,state);
          //FixMe: Make Provision For Operand Providing Store Address, Which Is Not Mapped As Part Of Kernel
	  // -> Fixed Apr 2022
          pe2 = getMappedPE(operand1,state);
          result = getRelativePosition(pe1,pe2);
          return result;
        }
	if(opType == constant)
        {
          result = Immediate;
          return result;
        }

      }
  break;

  case ld_data:
  result = DataBus;
  return result;
  break;
  case st_data:
    int operandID;
    for(std::vector<int>::iterator it = operands.begin(); it!= operands.end(); ++it)
    {
      string nodename = getNodeName(*it);
      if(((getNodeType(*it) != st_add) && (getNodeType(*it) != constant)) || (nodename.find("Const") != string::npos))
	operandID = *it;
    }

    if(getNodeType(operandID) == constant)
    {
      result = Register;
      return result;
      break;
    }
    if(!isLiveStoreNode(nodeID))
    {
      if(isScheduledMoreThanACycleApart(nodeID,operandID))
      {
	nodesThatReadRotatingRF.insert(nodeID);
	result = Register;
      }
      else
      {
        pe1 = getMappedPE(nodeID,state);
	pe2 = getMappedPE(operandID,state);
	result = getRelativePosition(pe1,pe2);
      }
    }
    else
    {
      if(isScheduledMoreThanACycleApart(nodeID,operandID)) {
	nodesThatReadRotatingRF.insert(nodeID);
	result = Register;
      }
      else {
	pe1 = getLiveVarMappedPE(nodeID);
	pe2 = getMappedPE(operandID,state);
	result = getRelativePosition(pe1,pe2);
      }
    }
    return result;
    break;
    //ROUTING NODE
  case route:
  case llvm_route:
  if(isScheduledMoreThanACycleApart(nodeID,it_inedge->second))
  {
    nodesThatReadRotatingRF.insert(nodeID);
    result = Register;
  }
  else
  {
    pe1 = getMappedPE(nodeID,state);
    pe2 = getMappedPE(it_inedge->second,state);
    result = getRelativePosition(pe1,pe2);
  }
  return result;
  break;
  case cgra_select:
  /*
   * Currently Phi Nodes Are Only Implemented As Selct Nodes.
   * For Conditional operations, We Will have 3 operands - 1. Condition 2. Op1 3. Op2
   * For that case, separate opcode cond_select is implemented.
   */
  {
    int operand1, operand2, selected;
    int dependence_distance = getDepenDistance(nodeID);
    /*
     * There can be case where both operands are involved to mapped node with recurrence edge of some weight
     * Usually, One of the operand should be regular true dependency with dependence weight 0.
     * Only that case is targeted here for following code.
     * Otherwise, dependence_distance and operands should be selected correspondingly.
     */
    if(operands.size() > 1)
    {
      if(getNodeType(operands[0]) == constant)
      {
        operand1 = operands[0]; //Initial Value
        operand2 = operands[1]; //Loop-carried value
      }
      else
      {
        operand1 = operands[1]; //Initial Value
        operand2 = operands[0]; //Loop-carried value
      }
    }
    else
      operand2 = operands[0];

    if(operands.size() > 1)
    {
      std::map<int,int>::iterator it1 = select_constant_node_result.find(nodeID);
      it1->second = operand1;
    }
    /* Now treat like other cases - add/route etc.
     * If operand is constant, result is immediate
     * Otherwise, check whether it is scheduled more than a cycle apart or not and give relevant position of PE or return register
     */
    int opType_initial = getNodeType(operand1);
    PEInputMux initial_result = Register;
    if(opType_initial == constant)
    {
      if(isLargeConstant(operand1))
        initial_result = Register;
      else
        initial_result = Immediate;
    }

    setlmuxphi(nodeID, initial_result);

    int opType = getNodeType(operand2);
    if(opType == constant)
    {
      result = Immediate;
      return result;
    }

    int op_sched_time = getScheduledTime(nodeID);
    int src_sched_time = getScheduledTime(operand2);

    if(opType == route)
    {
      if((src_sched_time - kernel_II) <= earliest_sched_time)
      {
        pe1 = getMappedPE(nodeID,state);
        pe2 = getMappedPE(operand2,state);
        result = getRelativePosition(pe1,pe2);
        return result;
      }
    }

    if(isMappedMoreThanACycleApart(operand2, nodeID, state_kernel, kernel_II)) //If operand2 is mapped a cycle apart than phi node
    {
      nodesThatReadRotatingRF.insert(nodeID);
      result = Register;
      return result;
    }
    else
    {
      pe1 = getMappedPE(nodeID,state);
      pe2 = getMappedPE(operand2,state);
      result = getRelativePosition(pe1,pe2);
      return result;
    }
    return result;
    break;
  }
  default:
    break;
  }

  //ALU Operations
  if(operands.size() > 0)
  {
    int operand1 = operands[0];
    int opType = getNodeType(operand1);
    if(opType == constant)
    {
      if(isLargeConstant(operand1))
	result = Register;
      else
	result = Immediate;
      return result;
    }

    if(nodetype == cond_select)
    {
      int operand1 = operands[0];
      int t1 = getScheduledTime(nodeID);
      int t2 = getScheduledTime(operand1);
      // Check if operand can give value to select directly through PEs.
      if((t2 > t1) && ((t2 + 1) != (t1 + kernel_II)))
      {
	std::multimap<int,int>::iterator it;
	for(it = out_edge.begin(); it != out_edge.end(); it++)
	{
	  int fromNode = it->first;
	  int toNode = it->second;
	  if((fromNode == operand1) && (toNode == nodeID))
          {
	    int distance = getDepenDistance(nodeID);
	    if(distance <= 0)
	      continue;
	    if(getNodeType(nodeID) != cond_select)
	      continue;
	    if(getSelectedPhiNode(nodeID) != operand1)
	      continue;
	    nodesThatReadRotatingRF.insert(nodeID);
	    result = Register;
	    return result;
	  }
	}
      }
    }
    
    if(isScheduledMoreThanACycleApart(nodeID,operand1))
    {
      nodesThatReadRotatingRF.insert(nodeID);
      result = Register;
      return result;
    }
    else
    {
      pe1 = getMappedPE(nodeID,state);
      pe2 = getMappedPE(operand1,state);
      result = getRelativePosition(pe1,pe2);
      return result;
    }
  }
}

//returns where the 2nd operand if this instruction is going to come from
PEInputMux getRMuxSelector(int nodeID,exec_state state)
{
  /*
   ************Memory Operations*******************
   if the instruction is ld_add, st_add
   {
   get all the operands of this node
   if(no operands)
   result = IMMEDIATE (set to 0)
   else
   {
   there will be atmost 1 operand for this instruction
   if the operand is constant
   result = IMMEDIATE (set to the constant value)
   if(the operand is scheduled more than a cycle apart)
   result = REGISTER
   else
   result =  Relative PE position of the operand to the PE this node is mapped on
   }
   }

   if the instruction is a ld_data
   result = immediate  (set immediate to 0)

   if the instruction is st_data
   result = immediate  (set immediate to 0)

   ***************Alu Operations**************
   Get the second operand (lets call it op)
   If(op is Constant)
   result = IMMEDIATE
   if(op is scheduled more than 1 cycle apart)
   result = REGISTER
   else
   result = Relative PE position of the operand to the PE this node is mapped on

   *****************Route Operation************
   result = Immediate (set to 0)
   */
  PEInputMux result = Register;
  int nodetype = getNodeType(nodeID);
  vector<int> operands;

  if(isPTypeInstruction(nodeID))
    operands = getOperandsPred(nodeID);
  else
    operands = getOperands(nodeID);

  int pe1,pe2;

  switch(nodetype){
    //ROUTING NODE
    case route:
    case llvm_route:
      //MEMORY OPERATIONS
    case ld_data:
    case st_data:
      result = Immediate;
      return result;
      break;
    case ld_add:
    case st_add:
      result = Immediate;
      return result;
      //Immediate Value For Phi Will Be Provided Through Left Mux Only If Selected Node Is Constant
    case cgra_select:
      setrmuxphi(nodeID, Register); //For Initial Values This Should Be zero, So register 0 which will be zero initially
      result = Immediate;   //For loop-carried value, Lmux = loop carried value, rumx = 0
      return result;  //It will be register 0
      break;
    default:
      break;
  }

  //ALU Operations
  if(operands.size() > 1)
  {
    int operand2 = operands[1];
    int opType = getNodeType(operand2);

    if(opType == constant)
    {
      if(isLargeConstant(operand2))
        result = Register;
      else
        result = Immediate;
      return result;
    }
    
    if(nodetype == cond_select)
    {
      int operand2 = operands[1];
      int t1 = getScheduledTime(nodeID);
      int t2 = getScheduledTime(operand2);
      if((t2 > t1) && ((t2 + 1) != (t1 + kernel_II)))
      {
        std::multimap<int,int>::iterator it;
        for(it = out_edge.begin(); it != out_edge.end(); it++)
        {
          int fromNode = it->first;
          int toNode = it->second;
          if((fromNode == operand2) && (toNode == nodeID))
          {
            int distance = getDepenDistance(nodeID);
            if(distance <= 0)
              continue;
            if(getNodeType(nodeID) != cond_select)
              continue;
            if(getSelectedPhiNode(nodeID) != operand2)
              continue;
            nodesThatReadRotatingRF.insert(nodeID);
            result = Register;
            return result;
          }
        }
      }
    }

    if(isScheduledMoreThanACycleApart(nodeID,operand2))
    {
      nodesThatReadRotatingRF.insert(nodeID);
      result = Register;
      return result;
    }
    else
    {
      pe1 = getMappedPE(nodeID,state);
      pe2 = getMappedPE(operand2,state);
      result = getRelativePosition(pe1,pe2);
      return result;
    }
  }
  else{
    result = Immediate;
  }
  return result;
}

//returns where the 3rd operand if this instruction is going to come from
PEInputMux getPMuxSelector(int nodeID,exec_state state)
{
  PEInputMux result = Register;
  int nodetype = getNodeType(nodeID);
  vector<int> operands;
  if(isPTypeInstruction(nodeID))
    operands = getOperandsPred(nodeID);
  else
    operands = getOperands(nodeID);

  int pe1,pe2;

  //ALU Operations
  if(operands.size() > 2)
  {
    int operand3 = operands[2];
    int opType = getNodeType(operand3);
    if(opType == constant)
    {
      if(isLargeConstant(operand3))
        result = Register;
      else
        result = Immediate;
      return result;
    }

    if(isScheduledMoreThanACycleApart(nodeID,operand3))
    {
      nodesThatReadRotatingRF.insert(nodeID);
      result = Register;
      return result;
    }
    else
    {
      pe1 = getMappedPE(nodeID,state);
      pe2 = getMappedPE(operand3,state);
      result = getRelativePosition(pe1,pe2);
      return result;
    }
  }
  else
    result = Immediate;
  return result;
}

//this function is responsible for returning the register number a node writes to
int getOutputRegisterNumber(int node)
{
  int result=-1;
  if(node_Output_Register.count(node) > 0)
    result = (node_Output_Register.find(node))->second;
  return result;
}

/* This function accepts the register number to which the src node writes to,
   computes the distance between the src and dest instruction and returns the
   register number the dest node should read from
   THE RF ROTATES TO THE LEFT
   0 1 2 3
   3 0 1 2
   2 3 0 1
   1 2 3 0
   0 1 2 3 */
int getRotatingRegNum(int regNum,int src,int dest, exec_state state)
{
  int Tsrc,Tdest;
  Tsrc = getScheduledTime(src);
  Tdest = getScheduledTime(dest);
  int srcMappedTime = getMappedTime(src,state);
  int destMappedTime = getMappedTime(dest,state);
  int diff = abs(Tsrc - Tdest);
  int distance=0; //Distance To be fixed and checked
  int pe = getMappedPE(dest,state);
  int config = pe_reg_config[pe];

  if((destMappedTime==0) && ((II-diff)==1))
    diff=0;
  /*
     1. diff <II
     src mapped b4 dest
     return same number
     src mapped after dest
     return number corresponding to 1 rotation
     2. diff >= II
     dist = floor(diff/II)
     src mapped before dest
     return number corresponding to dist rotation
     dest mapped before src
     return number corresponding to dist+11 rotation
   */

  if(diff >= kernel_II)
    II = kernel_II;

  if(diff < II)
  {
    if(srcMappedTime < destMappedTime)
    {
      int regs = srcnode_rotatingreg_readonly_map[src];
      srcnode_rotatingreg_readonly_map[src] = (regs > 1) ? regs : ((srcnode_rotatingreg_map[src] > 1) ? 0 : 1);
      regs = srcnode_rotatingreg_map[src];
      srcnode_rotatingreg_map[src] = (regs > 1) ? regs : 1;
      return regNum;
    }
    else
    {
      if(state == state_kernel)
        distance = 1;
      else
        distance = 0;
      int regs = srcnode_rotatingreg_map[src];
      srcnode_rotatingreg_map[src] = (regs > 1) ? regs : (distance);
      if(config > 0 && regNum > 0)
      return (regNum+(config-distance))%config;
    
      return 0; 
    }
  }
  else
  {
    distance = floor(diff/II);
    if(srcMappedTime < destMappedTime)
    {
      int regs = srcnode_rotatingreg_map[src];
      srcnode_rotatingreg_map[src] = (regs < (distance+1)) ? (distance+1) : regs;
      if(config > 0 && regNum > 0)
      return (regNum+(config-distance))%config;

      return 0; 
    }
    else
    {
      ++distance;
      int regs = srcnode_rotatingreg_map[src];
      srcnode_rotatingreg_map[src] = (regs < (distance)) ? (distance) : regs;
      if(config > 0 && regNum > 0)
        return (regNum+(config-distance))%config;

      return 0;
    }
  }
}

//This function is responsible for returning the register number that will act as operand 1
int getReg1Address(int nodeID,PEInputMux LMux,exec_state state)
{
  /*
   *************Memory Operations*******************
   if the instruction is ld_add, st_add
   result = register number this node is mapped to in mem_node_regNum

   if the instruction is a ld_data
   result = 0

   if the instruction is st_data
   {
   get the node id of the operand other than the varname and st_add
   if they are scheduled more than a cycle apart
   {
   reg=get the register that operand writes to
   result = getRotatingRegNum(reg,operandID,nodeID);
   }
   else
   result = 0
   }
   ***************Alu Operations**************
   Get the first operand (lets call it op)
   If(op is Constant)
   result = 0
   if(op is scheduled more than 1 cycle apart)
   reg=get the register that operand writes to
   result = getRotatingRegNum(reg,operandID,nodeID);
   else
   result =0

   *****************Route Operation************
   get the source node of the only incoming edge to this node
   if(src node is scheduled more than 1 cycle apart)
   reg=get the register that operand writes to
   result = getRotatingRegNum(reg,operandID,nodeID);
   else
   result =0

   *****************Select Operation************
   Follow Like Routing As We will Have Selected Node As Operand Part of Input Edge
   We will come here only if we require loop-carried value from register in case of phi
   We will come here if selected source node has value in register in case of if-then-else
   */
  int result = 0;
  if(LMux == Register)
  {
    int nodetype = getNodeType(nodeID);
    //there will be atmost 1 incoming edge to the routing node
    std::multimap<int, int>::iterator it_inedge = in_edge.find(nodeID);
    vector<int> operands = getOperands(nodeID);

    switch(nodetype){
      //MEMORY OPERATIONS
      case ld_add:
      case st_add:
        if(operands.size() == 0)
        {
          result = 0;
          if(isStoreNode(nodeID))  // Inspect me: should I be isStoreNode or isLiveStoreNode?
            result = mem_node_regNum[nodeID];
          return result;
        }
        else
        {
          int operand1 = it_inedge->second;
          int opType = getNodeType(operand1);
          if(opType == constant)
          {
            result = 0;
            return result;
          }

          int t1 = getScheduledTime(nodeID);
          int t2 = getScheduledTime(operand1);
          int diff = abs(t1-t2);
          int II_distance = floor(diff/kernel_II);

          if((II_distance > 0) || (isScheduledMoreThanACycleApart(nodeID,operand1)))
          {
            int srcReg = getOutputRegisterNumber(operand1);
            result = getRotatingRegNum(srcReg,operand1,nodeID,state);
            return result;
          }
          else
          {
            result = 0;
            return result;
          }
          break;
        }
      case ld_data:
        result = 0;
        return result;
        break;
      case st_data:
        int op;
        for(int i=0;i<operands.size();++i)
        {
          int type = getNodeType(operands[i]);
          string nodename = getNodeName(operands[i]);
          if((type!=constant && type!=st_add) || (nodename.find("Const") != string::npos))
          {
            op = operands[i];
            break;
          }
        }
        if(getNodeType(op) == constant)
        {
          result = 0;
          return result;
          break;
        }
        if(isScheduledMoreThanACycleApart(nodeID,op))
        {
          int srcReg = getOutputRegisterNumber(op);
          result = getRotatingRegNum(srcReg,op,nodeID,state);
          return result;
          break;
        }
        else
        {
          result = 0;
          return result;
          break;
        }
        //ROUTING NODE
      case route:
      case llvm_route:
        if(isScheduledMoreThanACycleApart(nodeID,it_inedge->second))
        {
          int srcReg = getOutputRegisterNumber(it_inedge->second);
          result = getRotatingRegNum(srcReg,it_inedge->second,nodeID,state);
        }
        else
        {
          result = 0;
        }
        return result;
        break;
      case cgra_select:
        {
          if(state == state_prolog)
          {
            int srcoperand = getSelectedConstantNode(nodeID);
            result = 0;
            if(isLargeConstant(srcoperand))
            {
              result = mem_node_regNum[srcoperand];
            }
            return result;
          }
          int srcoperand = getSelectedPhiNode(nodeID);
          if(isMappedMoreThanACycleApart(srcoperand, nodeID, state_kernel, kernel_II))
          {
            int srcReg = getOutputRegisterNumber(srcoperand);
            result = getRotatingRegNum(srcReg,srcoperand,nodeID,state);
          }
          else
          {
            result = 0;
          }
          return result;
          break;
        }
    }
    /*   ***************Alu Operations**************
         Get the first operand (lets call it op)
         If(op is Constant)
         result = 0
         if(op is scheduled more than 1 cycle apart)
         reg=get the register that operand writes to
         result = getRotatingRegNum(reg,operandID,nodeID);
         else
         result =0
     */
     
   
    if(operands.size() > 0)
    {
      int op1 = operands[0];
      int opType = getNodeType(op1);
      
      if(opType == constant)
      {
        if(isLargeConstant(op1)){
          //result = mem_node_regNum[op1];
          result = mem_node_pe_regNum[op1][prolog_map[nodeID]];
        }
        else
          result = 0;
          
        return result;
      }

      if(nodetype == cond_select)
      {
        // Fix: Operand writes in rotating registers and can be liveout
        if(isLiveOutData(op1))
          return mem_node_regNum[op1];

        int t1 = getScheduledTime(nodeID);
        int t2 = getScheduledTime(op1);
        if((t2 > t1)  && ((t2 + 1) != (t1 + kernel_II)))
        {
          std::multimap<int,int>::iterator it;
          for(it = out_edge.begin(); it != out_edge.end(); it++)
          {
            int fromNode = it->first;
            int toNode = it->second;
            if((fromNode == op1) && (toNode == nodeID))
            {
              int distance = getDepenDistance(nodeID);
              if(distance <= 0)
                continue;
              if(getNodeType(nodeID) != cond_select)
                continue;
              if(getSelectedPhiNode(nodeID) != op1)
                continue;

              int srcReg = getOutputRegisterNumber(op1);
              result = getRotatingRegNum(srcReg,op1,nodeID,state);
              return result;
            }
          }
        }
      }

      if(isScheduledMoreThanACycleApart(nodeID,op1))
      {
        int srcReg = getOutputRegisterNumber(op1);
        result = getRotatingRegNum(srcReg,op1,nodeID,state);
      }
      else
      {
        result = 0;
      }
      return result;
    }
  }
  else
  {
    return 0;
  }
}

int getReg2Address(int nodeID,PEInputMux RMux,exec_state state)
{
  /*
   ************Memory Operations*******************
   if the instruction is ld_add, st_add
   {
   get all the operands of this node
   if(no operands)
   result = 0
   else
   {
   there will be atmost 1 operand for this instruction
   if the operand is constant
   result = 0
   if(the operand is scheduled more than a cycle apart)
   {
   reg = getSourceRegNum(operand)
   result = getRotatingRegNum(reg,operandID,nodeID)
   }
   else
   result = 0
   }
   }

   if the instruction is a ld_data
   result = 0

   if the instruction is st_data
   result = 0

   ***************Alu Operations**************
   Get the second operand (lets call it op)
   If(op is Constant)
   result = 0
   if(op is scheduled more than 1 cycle apart)
   {
   reg = getSourceRegNum(operand)
   result = getRotatingRegNum(reg,operandID,nodeID)
   }
   else
   result = 0

   *****************Route Operation************
   result = 0
   */
  if(RMux == Register)
  {
    int result = 0;
    std::multimap<int, int>::iterator it_inedge = in_edge.find(nodeID);
    int nodetype = getNodeType(nodeID);
    vector<int> operands = getOperands(nodeID);
    int pe1,pe2;

    switch(nodetype){
      //ROUTING NODE
      case route:
      case llvm_route:
      case cgra_select:		//RMux Is Not Used In Case Of Phi/Select Nodes
        //MEMORY OPERATIONS
      case ld_data:
      case st_data:
        result = 0;
        return result;
        break;
      case ld_add:
      case st_add:
        result = mem_node_regNum[nodeID];
        return result;
        break;
      default:
        break;
    }

    //ALU Operations
    if(operands.size() > 1)
    {
      int operand2 = operands[1];
      int opType = getNodeType(operand2);
      if(opType == constant)
      {
        if(isLargeConstant(operand2))
          result = mem_node_regNum[operand2];
        else
          result = 0;
        return result;
      }

      if(nodetype == cond_select)
      {
        // Fix: Operand writes in rotating registers and can be liveout
        if(isLiveOutData(operand2))
          return mem_node_regNum[operand2];
        int t1 = getScheduledTime(nodeID);
        int t2 = getScheduledTime(operand2);
        if((t2 > t1)  && ((t2 + 1) != (t1 + kernel_II)))
        {
          std::multimap<int,int>::iterator it;
          for(it = out_edge.begin(); it != out_edge.end(); it++)
          {
            int fromNode = it->first;
            int toNode = it->second;
            if((fromNode == operand2) && (toNode == nodeID))
            {
              int distance = getDepenDistance(nodeID);
              if(distance <= 0)
                continue;
              if(getNodeType(nodeID) != cond_select)
                continue;
              if(getSelectedPhiNode(nodeID) != operand2)
                continue;
              int srcReg = getOutputRegisterNumber(operand2);
              result = getRotatingRegNum(srcReg,operand2,nodeID,state);
              return result;
            }
          }
        }
      }

      if(isScheduledMoreThanACycleApart(nodeID,operand2))
      {
        int srcreg = getOutputRegisterNumber(operand2);
        result = getRotatingRegNum(srcreg,operand2,nodeID,state);
        return result;
      }
      else
      {
        result = 0;
        return result;
      }
    }
  }
  else
    return 0;
}

int getRegPAddress(int nodeID,PEInputMux PMux,exec_state state)
{
  int result = 0;
  std::multimap<int, int>::iterator it_inedge = in_edge.find(nodeID);
  int nodetype = getNodeType(nodeID);
  vector<int> operands = getOperandsPred(nodeID);
  int pe1,pe2;

  if(operands.size() > 1)
  {
    int operand3 = operands[2];
    int opType = getNodeType(operand3);
    if(opType == constant)
    {
      if(isLargeConstant(operand3))
        result = mem_node_regNum[operand3];
      else
        result = 0;
      return result;
    }

    if(isScheduledMoreThanACycleApart(nodeID,operand3))
    {
      int srcreg = getOutputRegisterNumber(operand3);
      result = getRotatingRegNum(srcreg,operand3,nodeID,state);
      return result;
    }
    else
    {
      result = 0;
      return result;
    }
  }
  else
    return 0;
}

int calculate_reg_distance(int src,int dest, exec_state state)
{
  int distance=0;
  int Tsrc = getScheduledTime(src);
  int Tdest = getScheduledTime(dest);
  int diff = abs(Tsrc - Tdest);
  int srcMappedTime = getMappedTime(src,state);
  int destMappedTime = getMappedTime(dest,state);

  if(diff < kernel_II)
    distance = 0;
  else
    distance = floor(diff/kernel_II);

  if(srcMappedTime > destMappedTime)
    distance++;

  return distance;
}


//TODO what if there are multiple dependents of the same operation and they use
//the register we are going to release
//this function releases registers consumed by this node and updates the
//<pe,freeRegisters> map
void releaseRegisters(int nodeID,exec_state state)
{
  /*
     check if this register reads from the Rotating RF
     get the operands for this instruction
     for each operand
     if it writes to registers, get the reg num it writes to and the pe it is mapped to
     add that reg num to the free regs list of this pe
   */
  if(nodesThatReadRotatingRF.count(nodeID) > 0)
  {
    vector<int> operands = getOperands(nodeID);
    for(int i=0;i<operands.size();++i)
    {
      int op = operands[i];
      int regNum = getOutputRegisterNumber(op);
      int distance = calculate_reg_distance(op,nodeID,state);

      if(distance == 0)
      {
        if(regNum != -1)
        {
          int pe = getMappedPE(op,state);
          std::set<int> regs = pe_free_registers[pe];
          regs.insert(regNum);
          pe_free_registers[pe] = regs;
        }
      }
    }
  }
}

//gives a free register for this PE and updates the map storing the free PE list
int getFreeRegister(int pe, int num_wreg)
{
  int result=0;
  std::set<int> freeRegs = pe_free_registers[pe];
  
  for(int i=0; i<num_wreg; i++)
  {
    if(!freeRegs.empty())
    {
      result = *freeRegs.begin();
      freeRegs.erase(freeRegs.begin());
      pe_free_registers[pe] = freeRegs;
    }
    else
      return -1;
  }

  return result;
}

int calculate_distance(int src,int dest, exec_state state)
{
  int distance=0;
  int Tsrc = getScheduledTime(src);
  int Tdest = getScheduledTime(dest);
  int diff = abs(Tsrc - Tdest);

  int srcMappedTime = getMappedTime(src,state);
  int destMappedTime = getMappedTime(dest,state);

  if(diff < kernel_II)
    distance = 0;
  else
    distance = floor(diff/kernel_II);

  return distance;
}

//This function is responsible for returning the register number this node is
//supposed to write to
int getWriteRegAddress(int nodeID, int num_wreg, exec_state state)
{
  /*
   ***************Alu Operations, ld_data and Routing operations**************
   get the pe this node is mapped to
   get a free register from it
   return that
   */
  int pe=0;
  if(isLiveOutData(nodeID))
    return mem_node_regNum[nodeID];
  else if(isLiveStoreNode(nodeID))
    pe = getLiveVarMappedPE(nodeID);
  else if(isLargeConstant(nodeID))
    pe = getConstantMappedPE(nodeID)[0];
  else
    pe = getMappedPE(nodeID, state_kernel);

  return getFreeRegister(pe, num_wreg);
}

bool isWriteEnabled(int nodeID, int &distance)
{
  /*
   *************Memory Operations*******************
   if the instruction is ld_add, st_add, st_data
   result = false

   ***************Alu Operations ld_data and ROUTE OPERATION**************
   {
   get the outgoing edges where this node is the source
   if any of the destination instructions are scheduled more than a cycle apart
   result = true
   else
   result = false
   }

   */
  bool result = false;
  int opType = getNodeType(nodeID);
  distance = 0;
  std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
  //MEMORY OPERATIONS
  switch(opType){
    case ld_add:
    case st_add:
    case st_data:
      return false;
      break;
    default:
      break;
  }

  //ALU OPERATIONS,ld_data and route
  ret = out_edge.equal_range(nodeID);

  for (std::multimap<int,int>::iterator it=ret.first; it!=ret.second; ++it)
  {
    if(getNodeType(it->second) == cgra_select)
    {
      if(isMappedMoreThanACycleApart(nodeID,it->second,state_kernel,kernel_II))
      {
        result = true;
        distance = calculate_distance(it->second,nodeID,state_kernel)+1;
        break;
      }
    }
    else if(getNodeType(it->second) == cond_select)
    {
      int t1 = getScheduledTime(nodeID);
      int t2 = getScheduledTime(it->second);


      if((t1 > t2)  && ((t1 + 1) != (t2 + kernel_II)))
      {
        std::multimap<int,int>::iterator itt;
        for(itt = out_edge.begin(); itt != out_edge.end(); itt++)
        {
          int fromNode = itt->first;
          int toNode = itt->second;
          if((fromNode == nodeID) && (toNode == it->second))
          {
            distance = getDepenDistance(it->second);
            if(distance <= 0)
              continue;
            if(getNodeType(it->second) != cond_select)
              continue;
            if(getSelectedPhiNode(it->second) != nodeID)
              continue;
            result = true;
            distance = calculate_distance(it->second,nodeID,state_kernel)+1;
            break;
          }
        }
      }
      else if(isMappedMoreThanACycleApart(nodeID,it->second,state_kernel,kernel_II))
      {
        result = true;
        distance = calculate_distance(it->second,nodeID,state_kernel)+1;
        break;
      }
    }
    else if(isScheduledMoreThanACycleApart(nodeID,it->second))
    {
      result = true;
      distance = calculate_distance(it->second,nodeID,state_kernel)+1;
      break;
    }

    int phinode = getPhiNode(nodeID);
    if(phinode != -1)
    {
      if(isMappedMoreThanACycleApart(nodeID,getPhiNode(nodeID), state_kernel, kernel_II))
      {
        result = true;
        distance = calculate_distance(getPhiNode(nodeID),nodeID,state_kernel)+1;
        break;
      }
    }
  }
  return result;
}

//return the immediate value to be used for the instruction for this node
long getImmediate(int nodeID)
{
  /*
   *************Memory Operations*******************
   if the instruction is ld_add, st_add
   {
   get operands
   if(no operands)
   result = 0
   else
   result = number extracted from the node name
   }

   if the instruction is a ld_data,st_data
   result = 0

   ***************Alu Operations**************
   get operands
   get the node id of the operand with operation_type = constant
   get the name of the node
   result = extract the immediate field from this name
   *****************Route Operation************
   result = 0
   */
  long result = 0;

  vector<int> operands = getOperands(nodeID);
  int nodetype = getNodeType(nodeID);

  switch(nodetype){
    //MEMORY OPERATIONS
    case ld_data:
    case route:   //ROUTING NODE
      return result;
      break;
    case st_data:
      {
        if(isStoreNode(nodeID))
        {
          if(operands.size() == 0)
          {
            result = 0;
            return result;
            break;
          }
          else
          {
            for(int i=0;i<operands.size();++i)
            {
              string nodename = getNodeName(operands[i]);
              if((getNodeType(operands[i]) == constant) && (nodename.find("Const") != string::npos))
              {
                result = extractNumber(nodeid_names.find(operands[i])->second);
                return result;
                break;
              }
            }
          }
        }
        return result;
        break;
      }
    case ld_add:
    case st_add:
      {
        if(operands.size() == 0)
        {
          result = 0;
        }
        else
        {
          for(int i=0;i<operands.size();++i)
          {
            if(getNodeType(operands[i]) == constant)
            {
              result = extractNumber(nodeid_names.find(operands[i])->second);
            }
          }
        }
        std::map<int,unsigned>::iterator itt;
        itt = memory_access_alignment.find(nodeID);
        if(itt != memory_access_alignment.end())
          result = memory_access_alignment.find(nodeID)->second;

        return result;
        break;
      }
    case cgra_select:
      {
        /*
         * We have separated cgra_select (Phi's) from cond_select (selects)
         * For phi nodes, if operand is constant immediate is that value. Else 0.
         * So, Left Mux which is doing this selection between operands should get value of that operand and provide here.
         */
        int selected_node = getSelectedConstantNode(nodeID);    //Selected constant node

        if(operands.size() < 2)
          result = 0;
        else
        {
          std::map<int, string>::iterator it = nodeid_names.find(selected_node);
          string node_name = it->second;
          result = extractNumber(node_name);
        }
        setimmediatephi(nodeID, result);

        result = 0; //Result = 0 for recurrent input
        return result;
        break;
      }
    default:
      break;
  }

  //ALU OPs
  if(operands.size() == 0)
  {
    result = 0;
    return result;
  }
  else
  {
    result = 0;
    for(int i=0;i<operands.size();++i)
    {
      if((getNodeType(operands[i]) == constant) && (!isLargeConstant(operands[i])))
        result = extractNumber(nodeid_names.find(operands[i])->second);
    }
    return result;
  }

  return result;
}

//return true this instruction needs to assert the address bus
bool isAddressBusAssert(int nodeID)
{
  /*
     if the instruction is ld_add,st_add
     result = true
     else
     result = false
   */
  bool result = false;
  int nodetype = getNodeType(nodeID);
  if(nodetype == ld_add || nodetype == st_add)
    result = true;

  return result;
}

//return true this instruction needs to assert the data bus
bool isDataBusAssert(int nodeID)
{
  /*
     if the instruction is st_data

     result = true
     else
     result = false
   */
  bool result = false;
  if(getNodeType(nodeID) == st_data)
    result = true;

  return result;
}


//get the name of the variable to be loaded (this function is called for a ld_add operation)
string getloadvarname(int id)
{
  /*
     a ld_add node has only one outgoing edge (dest).
     dest will have 2 incoming edges. One from ld_add and the other node indicating the variable name
   */

  std::multimap<int, int>::iterator it1 = in_edge.find(id);
  int loadid;
  int var_add, var_mult;
  if(getNodeType(it1->second) == route)
    var_add = getRouteSrc(it1->second);
  else
    var_add = it1->second;

  if (var_add == 0)
  {
    std::multimap<int, int>::iterator it = out_edge.find(id);
    std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;

    if(getNodeType(it->second) == route)
      var_mult = getRouteSrc(it->second);
    else
      var_mult = it->second;

    ret = in_edge.equal_range(var_mult);
    for (std::multimap<int,int>::iterator it2=ret.first; it2!=ret.second; ++it2)
    {
      if(it2->second != id)
        loadid=it2->second;
    }
  }
  else
  {
    std::multimap<int, int>::iterator it = in_edge.find(id);

    std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;      

    if(getNodeType(it->second) == route)
      var_mult = getRouteSrc(it->second);
    else
      var_mult = it->second;


    //this if condition is a remedy for the following condition:
    // 1. if a load_add has a gPtr or gVar directly incoming to it rather
    //    than another node via another node.

    if(getNodeType(var_mult) != constant)
    {
      ret = in_edge.equal_range(var_mult);


      for (std::multimap<int,int>::iterator it2=ret.first; it2!=ret.second; ++it2)
      {
        if(getNodeType(it2->second) == constant)
        {
          loadid=it2->second;
          break;
        }
      }
    }
    else
    {
      loadid = var_mult;

    } 

  }

  if(getNodeType(loadid) == route)
    loadid=getRouteSrc(loadid);

  std::map<int, string>::iterator nameit = nodeid_names.find(loadid);
  return nameit->second;
}

//get the name of the variable to be stored (this function is called for a st_add operation)
string getstorevarname(int id)
{
  //a st_add node has only one outgoing edge (dest).
  //  dest will have 3 incoming edges. One from st_add, one from an operation containing the value to be stored and the other node indicating the variable name
  std::multimap<int, int>::iterator it1 = in_edge.find(id);
  int loadid = -100;
  int var_add, var_mult;
  int in_id = id; 
  if(getNodeType(it1->second) == route)
    var_add = getRouteSrc(it1->second);
  else
    var_add = it1->second;

  // Mahesh: the "while" loop was added to include corner cases 
  // where st_add has more than 1 layer of ops before the var name.

  while(loadid == -100)
  {
    if (var_add == 0)
    {
      std::multimap<int, int>::iterator it = out_edge.find(in_id);
      std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;

      if(getNodeType(it->second) == route)
        var_mult = getRouteSrc(it->second);
      else
        var_mult = it->second;

      ret = in_edge.equal_range(var_mult);
      for (std::multimap<int,int>::iterator it2=ret.first; it2!=ret.second; ++it2)
      {
        if(it2->second != in_id)
          loadid=it2->second;
      }
    }
    else
    {
      std::multimap<int, int>::iterator it = in_edge.find(in_id);
      std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;

      if(getNodeType(it->second) == route)
        var_mult = getRouteSrc(it->second);
      else
        var_mult = it->second;

      ret = in_edge.equal_range(var_mult);

      for (std::multimap<int,int>::iterator it2=ret.first; it2!=ret.second; ++it2)
      {
        if(getNodeType(it2->second) == constant)
        {
          loadid=it2->second;
          break;
        }
      }
    }
    in_id = var_add;
  }

  if(getNodeType(loadid) == route)
    loadid=getRouteSrc(loadid);

  std::map<int, string>::iterator nameit = nodeid_names.find(loadid);
  return nameit->second;
}


//get the name of the variable to be stored (this function is called for a st_add operation)
/*string getstorevarname(int id)
  {
//
//a st_add node has only one outgoing edge (dest).
//dest will have 3 incoming edges. One from st_add, one from an operation containing the value to be stored and the other node indicating the variable name
std::multimap<int, int>::iterator it1 = in_edge.find(id);
int loadid = -100;

if ( it1->second == 0)
{
std::multimap<int, int>::iterator it = out_edge.find(id);
std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
ret = in_edge.equal_range(it->second);
for (std::multimap<int,int>::iterator it2=ret.first; it2!=ret.second; ++it2)
{
if( (getNodeType(it2->second) == constant) ) //read-only or recurring variables
{
loadid=it2->second;
}
}
}
else
{
std::multimap<int, int>::iterator it = in_edge.find(id);

std::pair <std::multimap<int,int>::iterator, std::multimap<int,int>::iterator> ret;
ret = in_edge.equal_range(it->second); 
//ret = regi_in_edge.equal_range(it->first);

for (std::multimap<int,int>::iterator it2=ret.first; it2!=ret.second; ++it2)
{
if( getNodeType(it2->second) == constant)
{
loadid=it2->second;
break;
}
}
}

std::map<int, string>::iterator nameit = nodeid_names.find(loadid);
return nameit->second;
}*/ 

//return the node id's of all the nodes performing a ld_add/st_add
vector<int> getNonRecurringNodes()
{
  vector<int> result;

  //get set of constants and dump it into result
  for(std::set<int>::iterator it = largeConstants.begin(); it != largeConstants.end(); ++it)
  {
    result.push_back(*it);
  }

  /*for(std::map<int, int>::iterator it = nodeid_type.begin(); it != nodeid_type.end(); ++it)
    {
    string nodename = getNodeName(it->first);
    if((nodename.find("st_add") == string::npos) && (nodename.find("st_data") == string::npos))
    continue;
    result.push_back(it->first);
    }*/

  for(std::map<int, string>::iterator it = nodeid_names.begin(); it != nodeid_names.end(); ++it)
  { 
    string nodename = it->second; 
    int val; 
    std::istringstream(it->second) >> val; 
    //Instruction_Operation nodeop = (Instruction_Operation)val; 

    //if((nodeop != st_add ) && (nodeop != st_data))
    //continue;
    if((nodename.find("st_add") == string::npos) && (nodename.find("st_data") == string::npos))
      continue;
    result.push_back(it->first);
  }

  return result;
}

bool isLiveVarPEOccupied(int pe, int livenodes)
{
  std::map<int, int>::iterator it;
  for(int i=0; i<livenodes; i++)
  {
    int opID = getLiveNode(i);
    int livevar_data = getLiveVarData(opID);
    int mapped_pe = getMappedPE(livevar_data, state_kernel);
    if(pe == mapped_pe)
      return true;
  }

  return false;
}


// Select PE for store address based on PE for store data
// Search from the leftmost PE in a row and find a PE whose RF can accomodate 1 nonrecurring variable
// This is because we need 1 register to pre-load the address for store operation.
// The assumption is that we will be able to find 1 empty register in the RF of a PE in a row
// Such limitation can be avoided by integrating the live variable management to the mapping process.
unsigned getLeftPE(int pe, int livenodes)
{
  unsigned currentPE;
  unsigned leftmostPE = pe - (pe%Y);

  for(unsigned i=0; i<Y; i++)
  {
    currentPE = leftmostPE + i;

    if(pe_reg_config[currentPE] >= R)
      continue;

    if(currentPE == pe)
      continue;

    // let us consider A and B variables are to be stored and are mapped to same row.
    // The store function gets 2 cycles to store these, say, A in i and B in i+1.
    // if A's st_add is computed in the same PE where B is mapped, then the value to 
    // be stored by B is corrupted by the address. So the stored value is incorrect.
    // This check will rectify that.
    if(isLiveVarPEOccupied(currentPE, livenodes))
      continue; 

    return currentPE;
  }
  if(currentPE > Y)
    _FATAL("Please rerun the mapping. Cannot find PEs to map LiveOut Store!!"); 
}

/* Fix Me:
   Currently current_time obtained is the time where regular epilog ends
   And Before storing of Live variables start.
   It can be made efficient by many ways such that it starts from
   last sched time for corresponding PE.
 */


/* Fix me: Mahesh
   Currently if there are two liveout variables mapped to the same row
   then the second liveout variable's st_add and st_data is mapped to
   the next cycle. But it can be mapped to the same cycle but different
   row.
 */
int insert_livevar_store_nodes(int id, int pe, int current_time)
{
  int inserted = 0;
  int row_no = pe/Y;
  int time = current_time;
  while(!inserted)
  {
    if(time_pe_map_livevar.count(time) > 0)
    {
      std::set<int> rows = time_pe_map_livevar[time];

      if(rows.count(row_no))
      {
        time++;
      }
      else
      {
        rows.insert(row_no);
        time_pe_map_livevar[time] = rows;
        node_schedule_time[id] = time;
        node_schedule_time[id-1] = time;
        inserted=1;
      }
    }
    else
    {
      node_schedule_time[id] = time;
      node_schedule_time[id-1] = time;
      std::set<int> rows;
      rows.insert(row_no);
      time_pe_map_livevar[time] = rows;
      inserted = 1;
    }
  }

  if(schedule_time_nodes.count(time) > 0)
  {
    std::set<int> operations = schedule_time_nodes[time];
    operations.insert(id);
    operations.insert(id-1);
    schedule_time_nodes[time] = operations;
  }
  else
  {
    std::set<int> operations;
    operations.insert(id);
    operations.insert(id-1);
    schedule_time_nodes[time] = operations;
  }

  return time;

}

int generateLiveVarStoreSchedule(int max_schedule_time, int livenodes)
{
  int sched_time = max_schedule_time+1;
  int store_nodes_per_cgra_cycle = 2*X;
  int max_time = sched_time;
  int max_sched_time = sched_time;

  //Just two nodes store_add and store_data to be scheduled in a row
  //We map total of store_nodes_per_cgra_cycle nodes per cgra cycle
  for(int i=0; i<livenodes; ++i)
  {
    std::set<int>::iterator it;
    int opID = getLiveNode(i);
    string nodename = getNodeName(opID);
    int livevar_st_add, livevar_data, livevar_data_pe, livevar_add_pe;

    //We should place first store_data node for live-variable
    //It should be placed at same PE where corresponding data is mapped
    //After, we should map st_load node for the same live-variable to PE left to the PE on which st_data node is mapped

    if(getNodeType(opID) != st_data)
      continue;

    livevar_data = getLiveVarData(opID);
    livevar_st_add = opID - 1;	//As we know, store_add and store_data comes in pair, we get nodeid of corresponding store_add node

    if(getNodeType(livevar_data) != constant)
      livevar_data_pe = getMappedPE(livevar_data, state_kernel); //Node providing live variable data may or may not be in the epilog
    else
      livevar_data_pe = (X*Y/2);	//Randomly Selected PE
    cout << "LiveOut_data_pe: " << livevar_data_pe << "\tliveOut_data: " << livevar_data << "\n";
    livevar_add_pe = getLeftPE(livevar_data_pe, livenodes);
    cout << "LiveOut_add_pe: " << livevar_add_pe << "\tliveOut_add: " << livevar_st_add << "\n";

    max_time = insert_livevar_store_nodes(opID, livevar_data_pe, sched_time);
    node_schedule_time[opID] = max_time;
    node_schedule_time[opID-1] = max_time;

    livevar_pe_map.insert(std::pair<int,int>(opID,livevar_data_pe));
    livevar_pe_map.insert(std::pair<int,int>(opID-1,livevar_add_pe));
    liveout_storeop_map.insert(std::pair<int,int>(livevar_data,opID));
    max_sched_time = (max_time > max_sched_time) ? max_time : max_sched_time;
  }

  if(livenodes == 0){
    final_livevar_store_size = 0;
    livevar_store = new int[0];
    return max_time;
  }
  
  final_livevar_store_size = ((max_sched_time - max_schedule_time) * X * Y);
  livevar_store = new int[final_livevar_store_size];

  //Firstly, initialize each as no-op
  for(int i = 0; i < final_livevar_store_size; i++)
    livevar_store[i] = -1;

  for(int i = sched_time; i <= max_sched_time; i++)
  {
    //Get Nodes At Current Time And Schedule Them On Their Corresponding PEs
    if(schedule_time_nodes.count(i) > 0)
    {
      std::set<int> operations = schedule_time_nodes[i];
      std::set<int>::iterator it;
      for(it=operations.begin(); it != operations.end(); ++it)
      {
        int nodeID = *it;
        int pe = getLiveVarMappedPE(nodeID);
        int pe_index = ((i-sched_time)*X*Y) + pe;
        livevar_store[pe_index] = nodeID;
      }
    }
  }
  // We Do Not Print Mapping of Live Variables
  return max_time;
}


//This function generates a no operation instruction
CGRA_Instruction generateNOOP()
{
  Datatype dt = int32; 
  CGRA_Instruction noop(dt, NOOP,0,Self,Self,0,0,0,0,0,0,0);
  return noop;
}

void readRegConfig()
{
  int file_size=0, config=0;
  ifstream regiconfigfile;
  regiconfigfile.open("rfConfig.txt");

  //Get Total Number of Entries In File
  std::string line;
  while (getline(regiconfigfile, line))
    ++file_size;

  regiconfigfile.close();
  regiconfigfile.open("rfConfig.txt");

  //Read Data From Node File
  int i, pe;
  for(i = 0; i < file_size; i++)
  {
    regiconfigfile >> pe >> config;
    pe_reg_config.insert(std::pair<int,int>(pe,config));
  }

  if(R == 0)
  {
    for(i = 0; i < X*Y; i++)
      pe_reg_config.insert(std::pair<int,int>(i,-1));
  }

  regiconfigfile.close();
}

void generateRegiConfigInstructions()
{
  for(int i=0; i< (X*Y); i++)
  {
    Datatype dt = int32; 
    int LDi_imm = pe_reg_config[i] & 0x00000fff;
    Pred_Instruction LDi_ins(dt, setConfigBoundry,Immediate,Register,(PEInputMux) 4,0,0,0,LDi_imm);
    unsigned long dec1 = LDi_ins.DecodePredInstruction(&LDi_ins);

    printf("PE: %d\tConfiguration Boundary: %d\t%lx\n",i,LDi_imm,dec1);
    std::vector<Pred_Instruction> ins_set;
    ins_set.push_back(LDi_ins);
    initInstructions.insert(std::pair<int,std::vector<Pred_Instruction> >(i,ins_set));
  }
}

/*
   This function is responsible to genenrate all initialiization instructions.
   Generation of the LDi, LDMi and LDUi instructions that initialize the RF with nonreecurring values
Steps:
1. Get a list of all the nodes performing a ld_add or st_add
2. for each node
{
pe = get the PE it is mapped to.
n = get the number of livein or nonreecurring values mapped to that PE
if(n>0)
reg_num = n;
else
reg_num = 0;
if(pe_mem_op_map.contains(pe))
pe_mem_op_map[pe]++;
else
pe_mem_op_map.insert(pe,1);

mem_node_regNum.insert(node,reg_num);

generate 3 instructions, LDi, LDMi and LDUi for the INIT state of this PE
varname = getld/st varname;
addr = get address of varname from the symbol table
//the load immediate instructions have the LMUX as immediate and their WE set to 1.
//the RW bits tell us the register number where we want to write the address
//LDi
immediate = addr & 0x00000fff
//LDMi
immediate = (addr & 0x00fff000) >> 12
//LDUi
immediate = (addr & 0xff000000) >>24

}
 */
void generateINITinstructions(char* objfile)
{
  for(unsigned i=0; i < X*Y; i++)
  {
    pe_mem_op_cycles_map[i] = 0;
    pe_livein_load_map[(i/X)] = 0;
  }

  vector<int> nonrecNode = getNonRecurringNodes(); 

  if(nonrecNode.size() > 0)
  {
    for(int i=0;i<nonrecNode.size();++i)
    {
      int node = nonrecNode[i];
      int pe;
      std::vector<int> store_pe_set;
      int liveOutData = node;
      if(isLiveStoreData(node)) // && isLiveStoreNode(node))
      {
        liveOutData = getLiveOutToBeStored(node);
        pe = getLiveVarMappedPE(node);
      }
      else if(isLiveStoreNode(node)){
        pe = getLiveVarMappedPE(node);
      }
      else if(isLargeConstant(node)){
        store_pe_set = getConstantMappedPE(node);
	if(store_pe_set.size() == 0) continue;
      }
      else if(isLiveInNode(node)){
        pe = getLiveInMappedPE(node);
      }
      else{
        pe = getMappedPE(node, state_kernel);
      }

      if(store_pe_set.size() == 0) store_pe_set.push_back(pe);

      for(std::vector<int>::iterator pe_it = store_pe_set.begin(); pe_it != store_pe_set.end(); ++pe_it){
	int pe = *pe_it;
	int num_mem_ops = (pe_mem_op_map.count(pe) <= 0)?0: pe_mem_op_map[pe];
	int reg_num;    

	// Mahesh: LiveStore Nodes are stored in the non recurring part of the reg. 
	if(isStoreNode(node))  // Inspect me: should I be isStoreNode or isLiveStoreNode?
	  reg_num = num_mem_ops;
	else
	  reg_num = num_mem_ops + pe_reg_config[pe];

	if(pe_reg_config[pe] > R) {
	  cerr << "Configuration exceeds RF size\n";
	  exit (EXIT_FAILURE);
	}
	else
	  cout << "\treg_num: " << reg_num << " - PE: " << pe << " - Node: " << getNodeName(node) << endl;


	pe_mem_op_map[pe] = num_mem_ops + 1;

	if(isLiveStoreData(node))
	{
	  mem_node_regNum[liveOutData] = reg_num;
	  continue;
	}
	mem_node_regNum[node] = reg_num;
	
	// Added by Vinh Ta
	// Update: this is to fix error where the same constant/livein that uses reg appears in more than 1 PEs and have different regNum across them
	// TODO: need more work on this -> currently only used for getreg1address, should replace every mem_node_regNum occurence
	mem_node_pe_regNum[node][pe] = reg_num;
	
	pe_mem_op_cycles_map[pe] += 1; // moved from 3 to 1 with support of 64-bit insword
	maxMemoryOperations = ((num_mem_ops+1) > maxMemoryOperations)? (num_mem_ops+1):maxMemoryOperations;

	int id = getNodeType(node);

	if (id == ld_add || id == st_add)
	{
	  string var = (getNodeType(node) == ld_add)? getloadvarname(node):getstorevarname(node);
	  unsigned int addr = getVariableAddress(var,objfile);

	  std::multimap<int, int>::iterator it1 = in_edge.find(node);

	  if ( it1->second == 0)
	  {
	    printf("\nVariable Address (Hex): %x\t",addr);
	    cout<< "Node: " << node<<"\tPE: "<<pe<<"\tAddress (Decimal): "<<addr<<"\tRegNum: "<< reg_num << endl;
	    storeNonRecurringVal(addr, reg_num, pe);
	  }
	  else
	    getArrayAddress(pe,addr,node,reg_num,maxMemoryOperations,num_mem_ops);
	  }
	else if(id == constant)
	{
	  string nodename = getNodeName(node);
	  if(nodename.find("ConstInt") != string::npos)  //a constant
	  {
	    unsigned int largeconst; // cannot use long because of RF config
	    largeconst = (unsigned int) extractNumber(nodename);
	    printf("Large Constant (Hex): %x\tConstant (Decimal): %d\n",largeconst,largeconst);
	    storeNonRecurringVal(largeconst, reg_num, pe);
	  }
	  else if (nodename.find("ConstFP") != string::npos)
	  {
	    FLOAT largeFP; 
	    largeFP = extractFPNumber(nodename); 
	    printf("Floating Point Constant (Hex): %f\t",largeFP.f);
	    unsigned int ieee754=0;
	    ieee754 = (unsigned int) getDoublePrecision(largeFP); 
	    storeNonRecurringFPVal(ieee754, reg_num, pe); 
	  }
	  else
	  {
	    unsigned int addrOfLargeconst = getVariableAddress(nodename,objfile);
	    printf("Generating Instructions To Load Address (Hex) %x\n",addrOfLargeconst);
	    cout << nodename << endl;
	    storeNonRecurringVal(addrOfLargeconst, reg_num, pe);
	    Datatype DType = (Datatype)(getNodeDataType(node)); 

	    if(liveInoperand_node_list.count(node) != 0)
	    {
	      std::vector<Pred_Instruction> ins_set;

	      unsigned alignment = 4;
	      std::map<int,unsigned>::iterator itt;
	      itt = memory_access_alignment.find(node);
	      if(itt != memory_access_alignment.end())
		alignment = memory_access_alignment.find(node)->second;

	      int rowID = pe/Y;
	      int cycleDiff = pe_mem_op_cycles_map[pe] - pe_livein_load_map[rowID];
	      if(cycleDiff < 0)
	      {
		for(unsigned ii=0; ii < abs(cycleDiff); ii++)
		{
		  CGRA_Instruction noop_ins = generateNOOP();
		  unsigned long noop_decoded = noop_ins.DecodeInstruction(&noop_ins);
		  
		  Pred_Instruction temp(noop_decoded);
		  ins_set.push_back(temp.DecodePredInstruction(&temp));
		  pe_mem_op_cycles_map[pe]++;
		}
	      }
	      
	      // The datatype of load data generator depends on the value. If gVar or gPtr is loaded then
	      // the datatype is the datatype of that node. This ensures that the data is loaded into the correct membus. 
	      // The datatype of load data address generator is int32. This ensures that the data address in calculated
	      // by Int Execution unit. The Data_ins carries the info of the datatype to be loaded. 
	      cout << "Break: Node " << getNodeName(node) << " dt: " << DType << endl;
	      Datatype dt = DType; // int32; // This problem has been fixed by gem5 and dt of ld_add for loading fp should be float32
	      CGRA_Instruction LD_Add_ins(dt,(OPCode)address_generator,1,Register,Immediate,reg_num,0,0,0,alignment,1,0);
	      CGRA_Instruction LD_Data_ins(DType,Add,0,DataBus,Immediate,0,0,reg_num,1,0,0,0); //Mahesh check for FP.
	      pe_mem_op_cycles_map[pe] += 2;
	      pe_livein_load_map[rowID] = pe_mem_op_cycles_map[pe];

	      unsigned long dec1 = LD_Add_ins.DecodeInstruction(&LD_Add_ins);
	      unsigned long dec2 = LD_Data_ins.DecodeInstruction(&LD_Data_ins);
	      //printf("Loading dynamic constant value. LDA and LDD are %lu: %lu\n",dec1,dec2);
	      printf("Loading dynamic constant value. LDA and LDD are %lx: %lx in pe %d\n",dec1,dec2,pe);
	      Pred_Instruction temp1(dec1);
	      Pred_Instruction temp2(dec2);
	      printf("Load Dyn Cons %lx %lx\n", temp1.DecodePredInstruction(&temp1), temp2.DecodePredInstruction(&temp2));
	      ins_set.push_back(temp1.DecodePredInstruction(&temp1));
	      ins_set.push_back(temp2.DecodePredInstruction(&temp2));
	      initInstructions.insert(std::pair<int,std::vector<Pred_Instruction> >(pe,ins_set));
	    }

	    //generate instructions to load the address of dynamic constant and obtain and store the value
	    //avoid it in case of the base address for array
	    //Activate correct code in case of dynamic constant
	  }
	}
	init_cycles = (pe_mem_op_cycles_map[pe] > init_cycles)? (pe_mem_op_cycles_map[pe]) : init_cycles;
      }
    }
  }
  std::map<int,int>::iterator it; 
  std::cout << "pe mem op" << std::endl;
  for(it = pe_mem_op_cycles_map.begin(); it!= pe_mem_op_cycles_map.end(); it++) 
    std::cout << it->first << "\t" << it->second << std::endl; 
}

/*
   This function is responsible for generating prolog instructions
Steps:
1. get total prolog cycles
2. max_init_ins = get max number of live-in values mapped to a PE
3. total_init_cycles = max_init_ins*3 + 1
4. if((total_init_cycles%II) != 0), add a few noop cycles
This step is done to make sure that the registers are rotated a cycle before the actual prolog instructions start
5. for each pe, generate the init instructions and store the decoded instruction in the final_prolog array
6. add the dummy noop instructions
7. get the decoded prolog instructions and populate the final_prolog array
 */

void generateProlog(int extend_cycle)
{
  int total_cycles;
  int prolog_cycles = prolog_size/(X*Y);
  init_cycles = init_cycles + 1; //1 to configure each PE for regiser boundary
  //maxMemoryOperations*3 + 1

  int noop_cycles=0;

  if(init_cycles%kernel_II != 0)
  {
    noop_cycles = kernel_II - (init_cycles%kernel_II);
  }
  total_cycles = init_cycles + noop_cycles + prolog_cycles + extend_cycle;

  cout << "Original prolog cycles: " << total_cycles - extend_cycle << " - added cycles: " << extend_cycle << endl;

  final_config_size = init_cycles + noop_cycles;
  final_prolog_size = total_cycles * X * Y;
  final_prolog = new unsigned long[final_prolog_size];

  CGRA_Instruction noop_ins = generateNOOP();
  unsigned long noop_decoded = noop_ins.DecodeInstruction(&noop_ins);
  //populate the final_prolog array with init instructions
  //FOR EACH PE
  for(int i=0; i<(X*Y); ++i)
  {
    //FOR EACH MEM OPERATION
    if(initInstructions.count(i) > 0)
    {
      std::pair <std::multimap<int,std::vector<Pred_Instruction> >::iterator, std::multimap<int,std::vector<Pred_Instruction> >::iterator> ret;
      ret = initInstructions.equal_range(i);
      int j=0;
      //FOR EACH LD_IMM OPERATION
      for (std::multimap<int,std::vector<Pred_Instruction> >::iterator it=ret.first; it!=ret.second; ++it)
      {
        std::vector<Pred_Instruction> LDI_ins = it->second;
        for(int k = 0;k<LDI_ins.size(); ++k)
        {
          final_prolog[i + (X*Y)*j] = LDI_ins[k].DecodePredInstruction(&LDI_ins[k]);
          j++;
        }
      }

      //fill the rest of init cycles with noops
      if(j < init_cycles)
      {
        while(j< init_cycles)
        {
          final_prolog[i + (X*Y)*j] = noop_decoded;
          j++;
        }
      }
    }
    //fll with only noops
    else
    {
      for(int j = 0;j<init_cycles;++j)
        final_prolog[i + (X*Y)*j] = noop_decoded;
    }
  }

  //populate the final_prolog array with dummy noop instructions
  if(noop_cycles > 0)
  {
    for(int i = 0; i< (X*Y); ++i)
    {
      for (int j = init_cycles; j < (init_cycles + noop_cycles) ; ++j)
      {
        final_prolog[i + (X*Y)*j] = noop_decoded;
      }
    }
  }

  int prolog_start = (init_cycles + noop_cycles) * (X*Y);

  for(int i =0; i<prolog_size; ++i)
  {
    if(prolog[i] == -1)
    {
      final_prolog[prolog_start++] = noop_decoded;
    }
    else
    {
      CGRA_Instruction temp;
      if(getNodeType(prolog[i]) == cgra_select)
      {
        int distance = getDepenDistance(prolog[i]);
        int prolog_counter = phi_prolog_counter[prolog[i]];
        prolog_counter++;
        phi_prolog_counter[prolog[i]] = prolog_counter;

        if(prolog_counter <= distance)
          temp = nodeid_instruction_prolog[prolog[i]];
        else
          temp = nodeid_instruction[prolog[i]];

        final_prolog[prolog_start++] = temp.DecodeInstruction(&temp);
      }
      else if(isPTypeInstruction(prolog[i]))
      {
        Pred_Instruction temp = nodeid_Predinstruction[prolog[i]];
        final_prolog[prolog_start++] = temp.DecodePredInstruction(&temp);
      }
      else
      {
        temp = nodeid_instruction[prolog[i]];
        final_prolog[prolog_start++] = temp.DecodeInstruction(&temp);
      }

    }
  }

  cout<<"*******PROLOG*********\n";

  for(int i =0; i<(final_prolog_size - extend_cycle*X*Y); ++i)
    printf("%d: %lx\n",i,final_prolog[i]);
}

void generateKernel(int loopCtrl_node)
{
  // Update Apr 2022:
  // Kernel instruction for loop control node is moved to LE type for gem5 exit mechanism
  // LE inst branch offset in kernel are hardcoded to 0x3FF for gem5 to differentiate from prolog LE inst
  
  final_kernel_size = kernel_size;
  final_kernel = new unsigned long[final_kernel_size];

  CGRA_Instruction noop_ins = generateNOOP();
  unsigned long noop_decoded = noop_ins.DecodeInstruction(&noop_ins);

  for(int i =0; i<kernel_size; ++i)
  {
    if(kernel[i] == -1)
    {
      final_kernel[i] = noop_decoded;
    }
    else
    {
      if(isPTypeInstruction(kernel[i]))
      {
        Pred_Instruction temp = nodeid_Predinstruction[kernel[i]];
        final_kernel[i] = temp.DecodePredInstruction(&temp);
      }
      else
      {
	if(kernel[i] == loopCtrl_node){
	  CGRA_Instruction temp = nodeid_instruction[kernel[i]];
	  unsigned long temp_dec = temp.DecodeInstruction(&temp);
	  temp_dec |= (WIDTH_LE) << SHIFT_LE; // Set LE bit
	  unsigned long temp_imm = (temp_dec & WIDTH_IMMEDIATE) & WIDTH_LE_IMMEDIATE;
	  temp_dec &= ~(WIDTH_BRANCH_OFFSET << SHIFT_BRANCH_OFFSET); // Reset branch offset field
	  temp_dec |= ((MAX_BRANCH_OFFSET & WIDTH_BRANCH_OFFSET) << SHIFT_BRANCH_OFFSET);
	  temp_dec &= ~(WIDTH_LE_IMMEDIATE);
	  temp_dec |= temp_imm;
	  final_kernel[i] = temp_dec;
	  printf("GenerateKernel::loopCtrl_node: Previous inst: %lx - Current ins: %lx\n", temp.DecodeInstruction(&temp), temp_dec);
	}
	else{
	  CGRA_Instruction temp = nodeid_instruction[kernel[i]];
	  final_kernel[i] = temp.DecodeInstruction(&temp);
	}
      }
    }
  }

  cout<<"*******KERNEl*********\n";

  for(int i =0; i<final_kernel_size; ++i)
    printf("%d: %lx\n",i,final_kernel[i]);

}


void generateEpilog()
{
  //Print LiveVar Store Size To livevar_st_ins_count.txt
  ofstream myfile;
  myfile.open("livevar_st_ins_count.txt");
  myfile << final_livevar_store_size;
  myfile.close();

  // PAD with NOOPs at the end of the EPILOG
  int noop_cycles=0;
  final_epilog_size = epilog_size + final_livevar_store_size;

  // No need to pad NOOPs in epilog
  /*if((final_epilog_size/(X*Y))%kernel_II != 0)
  {
    noop_cycles = kernel_II - ((final_epilog_size/(X*Y))%kernel_II);
    }*/
  noop_cycles = (final_epilog_size == 0)? 1:0;
  cout << "Epilog cycle: " << epilog_size/(X*Y) << " - liveout store cycle: " << final_livevar_store_size/(X*Y) << " - padded NOOP cycles = " << noop_cycles << endl;
  final_epilog_size = final_epilog_size + (noop_cycles*(X*Y));
  final_epilog = new unsigned long[final_epilog_size];

  CGRA_Instruction noop_ins = generateNOOP();
  unsigned long noop_decoded = noop_ins.DecodeInstruction(&noop_ins);

  for(int i =0; i<epilog_size; ++i)
  {
    if(epilog[i] == -1)
    {
      final_epilog[i] = noop_decoded;
    }
    else if(isPTypeInstruction(epilog[i]))
    {
      Pred_Instruction temp = nodeid_Predinstruction[epilog[i]];
      final_epilog[i] = temp.DecodePredInstruction(&temp);
    }
    else
    {
      CGRA_Instruction temp = nodeid_instruction[epilog[i]];
      final_epilog[i] = temp.DecodeInstruction(&temp);
    }
  }
  //Now We Generate LiveVariable Store Instructions
  final_livevar_store = new unsigned long[final_livevar_store_size];

  for(int i =0; i<final_livevar_store_size; ++i)
  {
    if(livevar_store[i] == -1)
    {
      final_epilog[i+epilog_size] = noop_decoded;
    }
    else
    {
      CGRA_Instruction temp = nodeid_instruction[livevar_store[i]];
      final_epilog[i+epilog_size] = temp.DecodeInstruction(&temp);
      //printf("Store instr: %lx\n",final_epilog[i+epilog_size]); 
    }
  }

  if(noop_cycles > 0)
  {
    for (int j = (epilog_size + final_livevar_store_size); j < final_epilog_size; ++j)
    {
      final_epilog[j] = noop_decoded;
    }
  }

  cout<<"*******EPILOG*********\n";
  for(int i =0; i<final_epilog_size; ++i)
    printf("%d: %lx\n",i,final_epilog[i]);
}

void printSet(std::set<int> &arg)
{
  for(std::set<int>::iterator it = arg.begin(); it!=arg.end(); ++it)
    cout << *it << "\t";
  cout << "\n";
}

// Function below generates predicated insturction for select operation
void generatePredInstruction(int node)
{
  Datatype dt; 
  PredOPCode popc;
  int predic = 1;
  PEInputMux lmux,rmux,pmux;
  int reg1=0,reg2=0,regP=0;
  long immediate=0;

  popc = (PredOPCode)(getOpCode(node));
  dt = (getDataType(node));

  printf("Printing Pred Inst for Node: %d\n", node);
  printf("popc: %d\n", popc);
  printf("dt: %d\n", dt); 
  printf("getDatatype: %d\n", getDataType(node)); 

  lmux = getLMuxSelector(node, state_kernel);
  rmux = getRMuxSelector(node, state_kernel);
  pmux = getPMuxSelector(node, state_kernel);
  
  if(lmux == Register)
    reg1 = getReg1Address(node,lmux,state_kernel);
  else
    reg1 = 0;

  if(rmux == Register)
    reg2 = getReg2Address(node,rmux,state_kernel);
  else
    reg2 = 0;

  if(pmux == Register)
    regP = getRegPAddress(node,pmux,state_kernel);
  else
    regP = 0;

  releaseRegisters(node,state_kernel);

  if((lmux == Immediate) || (rmux == Immediate) || (pmux == Immediate))
    immediate = getImmediate(node);
  else
    immediate = 0;

  printf("FOR NODE %d:Pred Datatype:%d opcode:%d lmux:%d rmux:%d pmux: %d reg1:%d reg2:%d regP:%d imm:%d\n",node,dt,popc,lmux,rmux,pmux,reg1,reg2,regP,immediate);

  Pred_Instruction node_ins(dt,popc,lmux,rmux,pmux,reg1,reg2,regP,immediate);
  nodeid_Predinstruction[node] = node_ins;
  unsigned long decoded = node_ins.DecodePredInstruction(&node_ins);
  printf("Decoded %lx\n\n",decoded);
}

/* Function Below Generates Instructions For Non-Phi Nodes */
/* it is also used to generate for phi nodes in kernel and epilog*/ 
void generateInstructions(std::set<int> &nodes)
{
  Datatype DType;
  OPCode opc;
  int predic = 0;
  PEInputMux lmux,rmux;
  int reg1=0,reg2=0,wreg=0;
  bool we,abAssert,dbAssert;
  long immediate=0;
  int num_wreg=0;

  int prolog_reg1=0, prolog_reg2=0;

  //Generate Instructions For All Nodes, Except Phi Nodes
  for(std::set<int>::iterator it = nodes.begin(); it!=nodes.end(); ++it)
  {
    int node = *it;
    DType = getDataType(node);
    opc = getOpCode(node);
    
    // Check if the operation is P-type (not necessarily predicated) operation
    if(isPTypeInstruction(node))
    {
      generatePredInstruction(node); 
      continue;
    }

    lmux = getLMuxSelector(node, state_kernel);
    rmux = getRMuxSelector(node, state_kernel);

    if(lmux == Register)
    {
      reg1 = getReg1Address(node,lmux,state_kernel);
      prolog_reg1 = getReg1Address(node,lmux,state_prolog);
    }
    else
    {
      reg1 = 0;
      prolog_reg1=0;
    }

    if(rmux == Register)
    {
      reg2 = getReg2Address(node,rmux,state_kernel);
      prolog_reg2 = getReg2Address(node,rmux,state_prolog);
    }
    else
    {
      reg2 = 0;
      prolog_reg2=0;
    }

    releaseRegisters(node,state_kernel);
    we = isWriteEnabled(node,num_wreg); 
    if(we)
    {
      if(getNodeType(node)==cgra_select)
        wreg = node_Output_Register[node];
      else
        wreg =getWriteRegAddress(node,num_wreg,state_kernel);
    }
    else
      wreg = 0;

    node_Output_Register[node] = wreg;

    if((lmux == Immediate) || (rmux == Immediate))
      immediate = getImmediate(node);
    else
      immediate = 0;

    if(getNodeType(node) == cgra_select)
    {
      opc = (OPCode) LDi;
      predic = 1;
    }
    else if(isAddressBusAssert(node))
    {
      predic = 1;
    }
    else
      predic = 0;

    abAssert = isAddressBusAssert(node);
    dbAssert = isDataBusAssert(node);

    printf("FOR NODE %d: Datatype:%d opcode:%d lmux:%d rmux:%d reg1:%d reg2:%d we:%d wreg:%d imm:%d ab:%d db:%d\n",node,DType,opc,lmux,rmux,reg1,reg2,we,wreg,immediate,abAssert,dbAssert); 

    CGRA_Instruction node_ins(DType,opc,predic,lmux,rmux,reg1,reg2,wreg,we,immediate,abAssert,dbAssert);

    nodeid_instruction[node] = node_ins;

    unsigned long decoded = node_ins.DecodeInstruction(&node_ins);
    printf("Decoded %lx\n\n",decoded);

    if(getNodeType(node) != cgra_select)
    {
      CGRA_Instruction node_ins_prolog(DType,opc,predic,lmux,rmux,prolog_reg1,prolog_reg2,wreg,we,immediate,abAssert,dbAssert); 

      nodeid_instruction_prolog[node] = node_ins_prolog;

      if((prolog_reg1 != reg1) || (prolog_reg2 != reg2))
      {
        printf("Prolog! FOR NODE %d: Datatype:%d opcode:%d lmux:%d rmux:%d reg1:%d reg2:%d we:%d wreg:%d imm:%d ab:%d db:%d\n",node,DType,opc,lmux,rmux,prolog_reg1,prolog_reg2,we,wreg,immediate,abAssert,dbAssert);
        unsigned long decoded = node_ins_prolog.DecodeInstruction(&node_ins_prolog);
        printf("Decoded %lx\n\n",decoded);
      }
    }
  }
}

void generatePhiInstructions(std::set<int> &nodes)
{
  OPCode opc;
  Datatype dt; 
  int predic = 0;
  PEInputMux lmux,rmux;
  int reg1=0,reg2=0,wreg=0;
  bool we,abAssert,dbAssert;
  long immediate=0;
  int num_wreg=0;

  //Now generate instruction for phi nodes
  //We need to do this later here as now all predessessor nodes are placed
  for(std::set<int>::iterator it = nodes.begin(); it!=nodes.end(); ++it)
  {
    int node = *it;
    dt = getDataType(node);  
    opc = getOpCode(node);
    int node_type = getNodeType(node);

    if(node_type != cgra_select)
      continue;

    lmux = getLMuxSelector(node, state_kernel);
    rmux = getRMuxSelector(node, state_kernel);

    we = isWriteEnabled(node,num_wreg);

    if(we)
      wreg =getWriteRegAddress(node,num_wreg,state_kernel);
    else
      wreg = 0;
    node_Output_Register[node] = wreg;
    immediate = getImmediate(node);

    if(getNodeType(node) == cgra_select)
    {
      opc = (OPCode) LDi;
      predic = 1;
    }
    else if(isAddressBusAssert(node))
    {
      predic = 1;
    }
    else
      predic = 0;

    abAssert = isAddressBusAssert(node);
    dbAssert = isDataBusAssert(node);

    //Phi node have different operand selected in the prolog.
    lmux = getlmuxphi(node);
    rmux = getrmuxphi(node);
    immediate = getimmediatephi(node);

    if(lmux == Register)
      reg1 = getReg1Address(node,lmux,state_prolog);
    else
      reg1 = 0;
    reg2 = 0;

    printf("\nPhi! Prolog! FOR NODE %d: Datatype:%d opcode:%d lmux:%d rmux:%d reg1:%d reg2:%d we:%d wreg:%d imm:%d ab:%d db:%d\n",node,dt,opc,lmux,rmux,reg1,reg2,we,wreg,immediate,abAssert,dbAssert);

    CGRA_Instruction node_ins_prolog(dt,opc,predic,lmux,rmux,reg1,reg2,wreg,we,immediate,abAssert,dbAssert);
    nodeid_instruction_prolog[node] = node_ins_prolog;
    unsigned long decoded = node_ins_prolog.DecodeInstruction(&node_ins_prolog);
    printf("Decoded %lx\n",decoded);
  }
}

void generateStoreInstructions(std::set<int> &nodes)
{
  OPCode opc;
  Datatype dt; 
  int predic = 0;
  PEInputMux lmux,rmux;
  int reg1=0,reg2=0,wreg=0;
  bool we,abAssert,dbAssert;
  long immediate=0;
  int num_wreg=0;

  //Now generate instruction for live variable nodes
  //We need to do this later here as now all predessessor nodes are placed

  for(std::set<int>::iterator it = nodes.begin(); it!=nodes.end(); ++it)
  {
    int node = *it;
    dt = (Datatype)getNodeDataType(node);
    opc = getOpCode(node);
    int node_type = getNodeType(node);
    
    lmux = getLMuxSelector(node, state_kernel);
    rmux = getRMuxSelector(node, state_kernel);

    if(lmux == Register)
    {
      if(isLiveStoreData(node))
        reg1 = mem_node_regNum[getLiveOutToBeStored(node)];
      else
        reg1 = getReg1Address(node,lmux,state_kernel);
    }
    else
      reg1 = 0;

    if(rmux == Register)
    {
      if(isLiveStoreData(node))
        reg2 = mem_node_regNum[getLiveOutToBeStored(node)];
      else
        reg2 = getReg2Address(node,rmux,state_kernel);
    }
    else
      reg2 = 0;

    releaseRegisters(node,state_kernel);

    we = isWriteEnabled(node,num_wreg);
    if(we)
      wreg =getWriteRegAddress(node,num_wreg,state_kernel);
    else
      wreg = 0;

    node_Output_Register[node] = wreg;
    immediate = getImmediate(node);

    if(isAddressBusAssert(node))
    {
      predic = 1;
    }
    else
      predic = 0;
    abAssert = isAddressBusAssert(node);
    dbAssert = isDataBusAssert(node);

    printf("\nFOR NODE %d: Datatype:%d opcode:%d lmux:%d rmux:%d reg1:%d reg2:%d we:%d wreg:%d imm:%d ab:%d db:%d\n",node,dt,opc,lmux,rmux,reg1,reg2,we,wreg,immediate,abAssert,dbAssert);
    CGRA_Instruction node_ins(dt,opc,predic,lmux,rmux,reg1,reg2,wreg,we,immediate,abAssert,dbAssert);
    nodeid_instruction[node] = node_ins;

    unsigned long decoded = node_ins.DecodeInstruction(&node_ins);
    printf("Decoded %lx\n",decoded);

  }
}

void dumpProlog(int extend_cycle, int num_prolog_versions)
{
  int prolog_extend_size = extend_cycle * X * Y;  // # of inst added after original prolog
  int prolog_write_size = final_prolog_size - prolog_extend_size;  // # of inst for original prolog
  int prolog_version_size = (num_prolog_versions > 0)? prolog_extend_size/num_prolog_versions:0;  // # of inst for each prolog version
  FILE* prologFile;
  prologFile = fopen("prolog_ins.bin","wb");
  fwrite(&prolog_write_size,sizeof(int),1,prologFile);
  fwrite(&prolog_extend_size, sizeof(int),1,prologFile);
  fwrite(&prolog_version_size, sizeof(int),1,prologFile);
  fwrite(final_prolog,sizeof(unsigned long),final_prolog_size,prologFile);
  //fwrite(&prolog_extend_size, sizeof(int),1,prologFile); // write extend cycle to the end for compatibility with other non-extended insgen
  fclose(prologFile);
}

void dumpKernel()
{
  FILE* kernelFile;
  kernelFile = fopen("kernel_ins.bin","wb");
  fwrite(&final_kernel_size,sizeof(int),1,kernelFile);
  fwrite(final_kernel,sizeof(unsigned long),final_kernel_size,kernelFile);
  fclose(kernelFile);
}

void dumpEpilog()
{
  FILE* epilogFile;
  epilogFile = fopen("epilog_ins.bin","wb");
  fwrite(&final_epilog_size,sizeof(unsigned int),1,epilogFile);
  fwrite(final_epilog,sizeof(unsigned long),final_epilog_size,epilogFile);
  fclose(epilogFile);
}

void generateKernelCounter(int max_schedule_time)
{
  int KernelCounter = 100;
  FILE* count;
  count=fopen("./loop_iterations.txt","r");
  fscanf(count, "%d", &KernelCounter);
  fclose(count);

  int new_epilog_length = (epilog_size/(X*Y));

  int new_prolog_length = (prolog_size/(X*Y)) - earliest_sched_time;
  int total_unroll_cycles = new_prolog_length + new_epilog_length;
  int schedule_length = max_schedule_time - earliest_sched_time + 1;
  int unroll_count_cycles = total_unroll_cycles - schedule_length;

  float unroll_count_by_II = ((float) unroll_count_cycles)/kernel_II;
  float unroll_count_ceil = ceil(unroll_count_by_II);
  int unroll_count = ((int) unroll_count_ceil) - 1; //+ 1;

  KernelCounter = KernelCounter - unroll_count;

  ofstream myfile;
  myfile.open("kernel_count.txt");
  myfile << KernelCounter;
  myfile.close();
}

std::map<int,std::vector<std::pair<int,int>>> construct_iteration_map(){
  // Start from the 1st cycle of prolog and trace nodes
  // For the first II cycles, add every nodes
  // From the II cycles on, compare with already added nodes and only add new nodes
  // Might even have to go into to kernel to check if the first iteration is included

  std::map<int,std::vector<std::pair<int,int>>> ret;
  std::vector<int> added_nodes;
  for(int i=0; i<prolog_size; i++){
    if(prolog[i] == -1) continue;
    
    int cycle = getTime(i);
    int node_id = prolog[i];
    int pe_num = prolog_map[node_id];
    
    if(added_nodes.size() != 0){
      std::vector<int>::iterator it;
      for(it = added_nodes.begin(); it != added_nodes.end(); ++it)
	if((*it) == node_id) break;
    
      if(it != added_nodes.end())
	continue;
    }
    ret[cycle].push_back(std::make_pair(node_id,pe_num));
    added_nodes.push_back(node_id);
  }
  return ret;
}

std::tuple<std::map<int,int>,std::map<int,std::set<int>>> construct_stage_map(std::map<int,std::vector<std::pair<int,int>>> iteration_map){
  // Find stages for each node in kernel
  // Use schedule_time_node and iterate over cycles of kernel to analyze each node
  // For each kernel cycle, map its nodes to corresponding iteration cycle (populate cycle_node)
  // From the set of iteration cycle, assign stages from bottom up

  // In another approach, first identify at which iteration cycle does the kernel start
  // From that kernel start cycle to the next II-1 cycles, assign nodes to stage 0
  // From the kernel start cycle +1 going up II cycles, assign nodes to stage 0+i (repeat until reach start of iteration)

  std::map<int,int> node_stage_map; // map from node_id to stage
  std::map<int,std::set<int>> stage_cycle_map; // map from stage_id to set of iteration cycle

  // Identify iteration cycle that kernel starts
  std::set<int> kernel_nodes = schedule_time_nodes[0];
  // From the set of the first kernel cycle, find nodes with highest cycle and their corresponding cycle
  int iter_cycle_kernel_start = -1;
  for(auto node_it : kernel_nodes){
    auto iteration_it = iteration_map.begin();
    for(; iteration_it != iteration_map.end(); ++iteration_it){
      bool node_found = false;
      for(auto cycle_it = iteration_it->second.begin(); cycle_it != iteration_it->second.end(); ++cycle_it)
	if((*cycle_it).first == node_it) {node_found=true; break;}
      if(node_found) break;
    }
    int node_cycle = iteration_it->first;
    if(node_cycle > iter_cycle_kernel_start) iter_cycle_kernel_start = node_cycle;
  }

  // Since iter_cycle_kernel_start is found from the first kernel cycle and is highest among other iteration cycycles, it is the start cycle of the final stage in the iteration
  // First assign nodes from this cycle down II-1 cycles to stage 0
  //  Before this, find the number of cycles scheduled for an iteration
  if(iter_cycle_kernel_start < 0) _FATAL("Cannot find iter_cycle_kernel_start! Inspect me."); // This shouldn't happen

  int max_cycle = 0;
  for(auto iteration_it = iteration_map.begin(); iteration_it != iteration_map.end(); ++iteration_it)
    if(iteration_it->first > max_cycle) max_cycle = iteration_it->first;

  if(max_cycle < iter_cycle_kernel_start) _FATAL("Cannot find iteration max cycle! Inspect me.");
  
  for(int i = iter_cycle_kernel_start; i <= max_cycle; i++){
    std::vector<std::pair<int,int>> cycle_node_pe = iteration_map[i];
    for(auto node_it = cycle_node_pe.begin(); node_it != cycle_node_pe.end(); ++node_it)
      node_stage_map[(*node_it).first] = 0;
    stage_cycle_map[0].insert(i);
  }

  // Stage 0 nodes have been constructed, next construct nodes for stages up the iteration, each stage takes II cycles, repeat until reaching start of iteration
  for(int i = iter_cycle_kernel_start-1; i >= 0; i--){
    int stage_offset = (int)((iter_cycle_kernel_start - i - 1)/kernel_II) +1;
    std::vector<std::pair<int,int>> cycle_node_pe = iteration_map[i];
    for(auto node_it = cycle_node_pe.begin(); node_it != cycle_node_pe.end(); ++node_it)
      node_stage_map[(*node_it).first] = stage_offset;
    stage_cycle_map[stage_offset].insert(i);
  }

  return std::make_tuple(node_stage_map , stage_cycle_map);
}

void epilog_adjustment(std::map<int,std::vector<std::pair<int,int>>> iteration_map, std::map<int,int> node_stage_map, std::map<int,std::set<int>> stage_cycle_map, int loopCtrl_node){
  // This modifies epilog schedule such that the schedule would execute correctly
  // Iterate from the final iteration inwards
  // At each iteration, find location of a node stored in *epilog and replace with noop (-1)

  int stage_count = -1;
  for(std::map<int,int>::iterator it = node_stage_map.begin(); it != node_stage_map.end(); ++it)
    if(it->second > stage_count) stage_count = it->second;
  int loopCtrl_stage = node_stage_map[loopCtrl_node];
  int exceeds = stage_count - loopCtrl_stage;
  int iteration_cycle = 0;
  for(auto iteration_it = iteration_map.begin(); iteration_it != iteration_map.end(); ++iteration_it)
    if(iteration_it->first > iteration_cycle) iteration_cycle = iteration_it->first;

  //cout << "Epilog_Adj: stage count: " << stage_count << " - loopCtrl stage: " << loopCtrl_stage << " - exceeds: " << exceeds << " - iteration cycle: " << iteration_cycle << " - epilog_size: " << epilog_size << endl;
  
  std::vector<int> deleting_indices;
  for(int stage_i = stage_count; stage_i > loopCtrl_stage; stage_i--){
    // Start from top stage, delete nodes from after this stage in epilog down to end of iteration
    // Keep going till reaching the stage above loopCtrl_stage
    int start_cycle = int(*(stage_cycle_map[stage_i-1].begin()));
    for(int cycle_i = start_cycle; cycle_i <= iteration_cycle; cycle_i++){
      std::vector<std::pair<int,int>> cycle_nodes = iteration_map[cycle_i];
      for(auto node_it = cycle_nodes.begin(); node_it != cycle_nodes.end(); ++node_it){
	int node = (*node_it).first;
	int pe = (*node_it).second;
	int epilog_cycle = cycle_i - start_cycle;
	int index = epilog_cycle*X*Y + pe;
	if(node != epilog[index]) _FATAL("Error: deleting node and index don't match!");
	deleting_indices.push_back(index);
      }
    }
  }
  for(int i=0; i<deleting_indices.size(); i++)
    epilog[deleting_indices[i]] = -1;
  epilog_size -= (exceeds * kernel_II * X * Y);
  if(epilog_size < 0) epilog_size = 0;
}

std::tuple<int**,std::map<int,std::map<int,int>>> generate_prolog_versions(std::map<int,std::vector<std::pair<int,int>>> iteration_map, int loopCtrl_node, int* num_versions, int* version_cycle){
  
  int loopCtrl_cycle = node_time_map_prolog[loopCtrl_node];
  cout << "Loop control cycle: " << loopCtrl_cycle << endl;
  (*num_versions) = 0;
  for(int i=loopCtrl_cycle; i < (prolog_size/(X*Y)); i+=kernel_II)
    (*num_versions)++;
  cout << "Number of prolog versions: " << (*num_versions) << endl;
  int iteration_cycle = -1;
  int loopCtrl_iter_cycle = -1;
  for(auto iter_it = iteration_map.begin(); iter_it != iteration_map.end(); ++iter_it){
    if(iter_it->first > iteration_cycle) iteration_cycle = iter_it->first;
    for(auto cycle_it = iter_it->second.begin(); cycle_it != iter_it->second.end() && loopCtrl_iter_cycle == -1; ++cycle_it)
      if(cycle_it->first == loopCtrl_node) loopCtrl_iter_cycle = iter_it->first;
  }
  FATAL(iteration_cycle == -1 || loopCtrl_iter_cycle == -1, "Fatal: Cannot find iteration cycle or loopCtrl_iter_cycle.");

  
  cout << "Iteration cycle: " << iteration_cycle << " - loopCtrl_iter_cycle: " << loopCtrl_iter_cycle << endl;
  (*version_cycle) = iteration_cycle - loopCtrl_iter_cycle;
  int** ret = new int*[(*num_versions)];
  for(int version_i = 0; version_i < (*num_versions); version_i++){
    ret[version_i] = new int[(iteration_cycle - loopCtrl_iter_cycle)*X*Y + final_livevar_store_size];
    for(int j = 0; j < (iteration_cycle - loopCtrl_iter_cycle)*X*Y; j++)
      ret[version_i][j] = -1;
    
    for(int prolog_cycle_i = loopCtrl_iter_cycle+1; prolog_cycle_i <= iteration_cycle; prolog_cycle_i++){
      std::vector<std::vector<std::pair<int,int>>> cycle_node_pe;
      for(int stage_i = prolog_cycle_i, version_j = 0; stage_i <= iteration_cycle && version_j <= version_i; stage_i+=kernel_II){
	cycle_node_pe.push_back(iteration_map[stage_i]);
	version_j++;
      }
      
      for(auto cycle_it = cycle_node_pe.begin(); cycle_it != cycle_node_pe.end(); ++cycle_it)
	for(auto node_it = (*cycle_it).begin(); node_it != (*cycle_it).end(); ++node_it){
	  int pe = node_it->second;
	  int index = (prolog_cycle_i - loopCtrl_iter_cycle -1)*X*Y + pe;
	  ret[version_i][index] = node_it->first;
	}
    }
  }

  // Construct a map from prolog version to phi node count 
  // Start from loopCtrl_cycle, iterate up to count phi nodes for a version
  // Then go down II cycles and iterate up to count again for next version
  // Repeat for (*num_versions) times
  std::map<int,std::map<int,int>> prolog_version_phi_counter_map; // prolog version to phi node_id to counter
  for(int version_i = 0; version_i < (*num_versions); version_i++){
    for(int cycle_i = loopCtrl_cycle + (kernel_II * version_i); cycle_i >= 0; cycle_i--){
      for(int x=X-1; x>=0; x--)
	for(int y=Y-1; y>=0; y--){
	  int node_id = prolog[cycle_i*X*Y + x*X + y];
	  if(node_id != -1 && getNodeType(node_id) == cgra_select){
	    int counter = prolog_version_phi_counter_map[version_i][node_id];
	    counter++;
	    prolog_version_phi_counter_map[version_i][node_id] = counter;
	  }
	}
    }
  }
  
  return std::make_tuple(ret,prolog_version_phi_counter_map);
}

void extendProlog(int** multi_prolog_mapping, int n_version, int version_cycle, std::map<int,std::map<int,int>> prolog_version_phi_counter){
  // Start decoding prolog versions and insert to final_prolog
  
  CGRA_Instruction noop_ins = generateNOOP();
  unsigned long noop_decoded = noop_ins.DecodeInstruction(&noop_ins);
  int start_cycle = init_cycles + prolog_size/(X*Y);
  
  if(init_cycles%kernel_II != 0) start_cycle += (kernel_II - (init_cycles%kernel_II)); // Add noop cycles
  
  for(int version_i = 0; version_i < n_version; version_i++){
    std::map<int,int> phi_counter;
    for(int cycle_i = 0; cycle_i < version_cycle + (final_livevar_store_size/(X*Y)); cycle_i++)
      for(int x = 0; x<X; x++)
	for(int y = 0; y<Y; y++){
	  int final_index = start_cycle*X*Y +
	    version_i*(version_cycle + (final_livevar_store_size/(X*Y)))*X*Y +
	    cycle_i*X*Y + x*X + y;
	  int node_id = multi_prolog_mapping[version_i][cycle_i*X*Y + x*X + y];
	  if(node_id == -1)
	    final_prolog[final_index] = noop_decoded;
	  else{
	    CGRA_Instruction temp;
	    if(getNodeType(node_id) == cgra_select){
	      int distance = getDepenDistance(node_id);
	      int counter = phi_counter[node_id] + 1;
	      phi_counter[node_id] = counter;
	      counter += prolog_version_phi_counter[version_i][node_id];
	      if(counter <= distance)
		temp = nodeid_instruction_prolog[node_id];
	      else
		temp = nodeid_instruction[node_id];
	      final_prolog[final_index] = temp.DecodeInstruction(&temp);
	      printf("Added node %d @ index %d\n  Decoded: %lx\n", node_id, final_index, final_prolog[final_index]);
	    } else if(isPTypeInstruction(node_id)){
	      Pred_Instruction temp_pred = nodeid_Predinstruction[node_id];
	      final_prolog[final_index] = temp_pred.DecodePredInstruction(&temp_pred);
	      printf("Added node %d @ index %d\n  Decoded: %lx\n", node_id, final_index, final_prolog[final_index]);
	    } else {
	      temp = nodeid_instruction[node_id];
	      final_prolog[final_index] = temp.DecodeInstruction(&temp);
	      printf("Added node %d @ index %d\n  Decoded: %lx\n", node_id, final_index, final_prolog[final_index]);
	    }
	  }
	}
  }
}

void modifyProlog(int loopCtrl_node, int n_version, int version_cycle){
  int noop_cycles = (init_cycles%kernel_II != 0)? (kernel_II - (init_cycles%kernel_II)) : 0;
  int start_idx = (init_cycles + noop_cycles)*X*Y;  // Index for final_prolog after config cycles
  
  cout << "Modify Prolog: start index = " << start_idx << endl;
  for(int prolog_idx = 0, version_i = 0; prolog_idx < prolog_size; prolog_idx++){
    if(prolog[prolog_idx] == loopCtrl_node){
      unsigned long temp = final_prolog[start_idx + prolog_idx];
      temp |= (WIDTH_LE) << SHIFT_LE; // Set LE bit
      unsigned long temp_imm = (temp & WIDTH_IMMEDIATE) & WIDTH_LE_IMMEDIATE;

      // Calculate offset
      int branch_target = start_idx + prolog_size + version_i*version_cycle*X*Y;
      int current_cycle = prolog_idx - (prolog_idx % (X*Y));
      int offset = (branch_target - start_idx - current_cycle)/(X*Y);  // Offset in terms of cycle (multiple of PEs)
      printf(" Index = %d - Target = %d - Offset = %d\n", (start_idx + prolog_idx), branch_target, offset);
      
      temp &= ~(WIDTH_BRANCH_OFFSET << SHIFT_BRANCH_OFFSET); // Reset branch offset field
      temp |= ((offset & WIDTH_BRANCH_OFFSET) << SHIFT_BRANCH_OFFSET);
      temp &= ~(WIDTH_LE_IMMEDIATE);
      temp |= temp_imm;
      printf(" Previous insword: %lx - Current insword: %lx\n", final_prolog[start_idx + prolog_idx], temp);
      final_prolog[start_idx + prolog_idx] = temp;
      version_i++;
    }
  }
}

//driver function
int main(int argc, char* argv[])
{
  if(argc<14)
  {
    cout << "Usage: opcodegen FINALNODEFILE EDGEFILE LLVMNODEFILE LLVMEDGEFILE OBJFILE PrologFile KernelFile EpilogFile X Y R LIVEOUTNODEFILE LIVEOUTEDGEFILE"; // LIVEINNODEFILE LIVEINEDGEFILE";
    return -1;
  }

  //CGRA DIMENSIONS
  X = atoi(argv[9]);
  Y = atoi(argv[10]);
  R = atoi(argv[11]);

  string line, nodename;
  int nodeID,node_type,other_nodeID,node_datatype;
  int livenodes=0;

  //Read the final node file
  ifstream finalnodefile (argv[1]);
  if(finalnodefile.is_open())
  {
    while ( getline(finalnodefile,line) )
    {
      istringstream strout(line);
      strout >> nodeID >> node_type >> node_datatype;
      std::pair<int,int> e2(nodeID,node_type);
      nodeid_type.insert(std::pair<std::pair<int, int>,int>(e2, node_datatype));
      if(node_type == route)
	  routingNodes.insert(nodeID);    
        //routingNodes.push_back(nodeID);
    }
  }
  finalnodefile.close();

  //read the Edge file dumped by the mapping technique
  ifstream regiEdgeFile (argv[2]);
  int operandOrder,distance;
  std::string dependencyType;

  if(regiEdgeFile.is_open())
  {
    while ( getline(regiEdgeFile,line) )
    {
      istringstream strout(line);
      strout >> nodeID >> other_nodeID >> distance >> dependencyType >> operandOrder;
      cout<<"\nUPDATING EDGES " << nodeID<<":"<< other_nodeID<<endl;
      out_edge.insert(std::pair<int,int>(nodeID,other_nodeID));
      in_edge.insert(std::pair<int,int>(other_nodeID,nodeID));

      std::pair<int,int> outGoingEdge(nodeID,other_nodeID);
      operand_order_map.insert(std::pair< std::pair<int,int>,int >(outGoingEdge,operandOrder));

      if((getNodeType(other_nodeID) == cgra_select) 	//In case of Phi or Select Node
          || (getNodeType(other_nodeID) == cond_select)) // Added for Selects
      {
        if(distance > 0)
        {
          cout<<"\nUPDATING DEPENDENCY EDGES FOR NODE  " << other_nodeID <<":"<< distance << endl;
          to_node_dependency_distance.insert(std::pair<int,int>(other_nodeID,distance));
          select_phi_node_result.insert(std::pair<int,int>(other_nodeID,nodeID));
        }
      }
    }
  }
  regiEdgeFile.close();

  int constantnodes = 0;
  int dfgnodes = 0;
  unsigned alignment = 4;

  //read the node file dumped by llvm (dfg generator) to get the name of nodes
  //(used for constant nodes) datatypes are not dumped because this file is
  // required only for the name of the nodes.
  ifstream llvmNodeFile (argv[3]);
  if(llvmNodeFile.is_open())
  {
    while ( getline(llvmNodeFile,line) )
    {
      istringstream strout(line);
      strout >> nodeID >> node_type >> nodename >> alignment;

      nodeid_names.insert(std::pair<int,string>(nodeID,nodename));
      dfgnodes++;

      if(node_type == constant)
      {
        constantnodes++;
        if(isLargeConstant(nodeID))
          largeConstants.insert(nodeID);
      }
      else if((node_type == ld_add) || (node_type == st_add))
      {
        memory_access_alignment.insert(std::pair<int, unsigned>(nodeID,alignment));
      }
      else if(alignment > 0)
        memory_access_alignment.insert(std::pair<int, unsigned>(nodeID,alignment));
    }
  }
  llvmNodeFile.close();

  //read the llvm generated edge file
  //populate the out edge and in edge maps.
  //populate the operand orders

  int loopCtrl_node = -1; // "from" node of LCE edges
  bool LCE_found = false;

  //IMPORTANT: The out_edge and in_edge map contain the edges genrated by the mapping technique
  //and the edges from the constant nodes to the other nodes.
  ifstream llvmEdgeFile (argv[4]);
  if(llvmEdgeFile.is_open())
  {
    while ( getline(llvmEdgeFile,line) )
    {
      istringstream strout(line);
      strout >> nodeID >> other_nodeID >> distance >> dependencyType >> operandOrder;

      if(dependencyType.compare("LCE") == 0){
	if(loopCtrl_node != -1 && loopCtrl_node != nodeID) _FATAL("Multiple loopCtrl nodes detected! Further works required to handle this case.\n");
	loopCtrl_node = nodeID;
	LCE_found = true;
	continue;
      }

      if(getNodeType(nodeID) == constant)
      {
        cout<<"\nUPDATING EDGES " <<nodeID<<":"<<other_nodeID<<endl;
        out_edge.insert(std::pair<int,int>(nodeID,other_nodeID));
        in_edge.insert(std::pair<int,int>(other_nodeID,nodeID));
        std::pair<int,int> outGoingEdge(nodeID,other_nodeID);
        operand_order_map.insert(std::pair< std::pair<int,int>,int >(outGoingEdge,operandOrder));

        if(isLargeConstant(nodeID))
	  const_node_map[nodeID].push_back(other_nodeID);
          //const_node_map.insert(std::pair<int,int>(nodeID,other_nodeID));

        if(dependencyType.find("LIE") != string::npos)
          liveInoperand_node_list.insert(std::pair<int,int>(nodeID,other_nodeID)); 
      }
      else if(getNodeType(other_nodeID) == constant)
      {
        //Delete duplicated entry for reserving register for
        // storing address of the liveout variable
        if(isLargeConstant(other_nodeID))
        {
          largeConstants.erase(other_nodeID);
          constantnodes--;
        }
      }

      if(getNodeType(other_nodeID) == cond_select && dependencyType.find("PRE") != string::npos)
        pred_pairs.insert(std::pair<int,int>(nodeID,other_nodeID));

      // Check for similar edge with different operandOrder. If so, add it
      // This can be case for the operation such as square
      std::multimap<int,int>::iterator it;
      for(it = out_edge.begin(); it != out_edge.end(); it++)
      {
        int fromNode = it->first;
        int toNode = it->second;
        if((fromNode != nodeID) || (toNode != other_nodeID))
          continue;
        std::pair<int,int> edge(fromNode,toNode);
        std::multimap<std::pair<int,int>,int>::iterator itt;
        for(itt = operand_order_map.begin(); itt != operand_order_map.end(); itt++)
        {
          if((itt->first.first != fromNode) || (itt->first.second != toNode))
            continue;
          int oporder = itt->second;
          if(oporder == operandOrder)
            continue;
          cout<<"\nUPDATING EDGES " <<nodeID <<":"<<other_nodeID << "\t" << operandOrder << endl;
          std::pair<int,int> outGoingEdge(nodeID,other_nodeID);
          operand_order_map.insert(std::pair< std::pair<int,int>,int >(outGoingEdge,operandOrder));
        }
      }
    }
  }
  llvmEdgeFile.close(); 
  //read the live-out node file dumped by llvm (dfg generator) to get the information about live nodes and corresponding store nodes
  //(used for live-out operations only, to store data back into the memory, which can be used later by processor core)
  ifstream LiveNodeFile (argv[12]);
  if(LiveNodeFile.is_open())
  {
    while ( getline(LiveNodeFile,line) )
    {
      istringstream strout(line);
      strout >> nodeID >> node_type >> nodename >> alignment >> node_datatype;

      //Add Only If It Is Not Available Previously - Applicable to store_add and store_data nodes for live variables
      std::multimap< std::pair<int,int>, int>::iterator it;
      int livenode_present=0;
      for(it = nodeid_type.begin(); it != nodeid_type.end(); ++it)
      {
        if(it->first.first == nodeID)
        {
          livenode_present=1;
          break;
        }
      }
      if(livenode_present == 0)
      {
	nodeid_names.insert(std::pair<int,string>(nodeID,nodename));
        std::pair<int,int> e2(nodeID,node_type);
        nodeid_type.insert(std::pair<std::pair<int, int>,int>(e2, node_datatype));
        //nodeid_type.insert(std::pair<int,int>(nodeID,node_type));
        livevar_node_list.insert(std::pair<int,int>(livenodes,nodeID));
        livenodes++;

        if(alignment > 0)
          memory_access_alignment.insert(std::pair<int, unsigned>(nodeID,alignment));

	if(node_type == constant){
	  constantnodes++;
	  if(isLargeConstant(nodeID)){
	    largeConstants.insert(nodeID);
	  }
	}
      }
    }
  }
  LiveNodeFile.close();

  //read the llvm generated live-out variable's edge file
  //populate the edges for live-out variable
  //populate the operand orders
  //All edges are required and new so should be added
  ifstream LiveEdgeFile (argv[13]);
  if(LiveEdgeFile.is_open())
  {
    while ( getline(LiveEdgeFile,line) )
    {
      int operandOrder,distance;
      string dependencyType;
      istringstream strout(line);
      strout >> nodeID >> other_nodeID >> distance >> dependencyType >> operandOrder;
      std::pair<int,int> outGoingEdge(nodeID,other_nodeID);
      operand_order_map.insert(std::pair< std::pair<int,int>,int >(outGoingEdge,operandOrder));

      cout<<"\nUPDATING EDGES " <<nodeID<<":"<<other_nodeID<<endl;
      out_edge.insert(std::pair<int,int>(nodeID,other_nodeID));
      in_edge.insert(std::pair<int,int>(other_nodeID,nodeID));
    }
  }
  LiveEdgeFile.close();
  //update the operand orders to incorporate routing nodes from the dfg
  //generated by the mapping technique
  updateOperandOrder();

  //read the prolog file
  int opID,num_ops,i=0;
  ifstream prologFile (argv[6]);
  if(prologFile.is_open())
  {
    while ( getline(prologFile,line) )
    {
      istringstream strout(line);
      strout >> prolog_size;
    }
    prolog = new int[prolog_size];
  }
  prologFile.close();
  II = prolog_size/(X*Y);
  prologFile.open(argv[6], ifstream::in);
  cout << "file ptr:"<<prologFile.tellg()<<"\topen:"<<prologFile.is_open() <<"\t prolog_size:"<< prolog_size<<"\n"<<endl;
  if(prologFile.is_open())
  {
    while ( getline(prologFile,line) )
    {
      istringstream strout(line);
      strout >> opID;
      if(i<prolog_size)
        prolog[i++] = opID;
    }
  }
  prologFile.close();

  //read the kernel file
  i=0;
  ifstream kernelFile (argv[7]);
  if(kernelFile.is_open())
  {
    while ( getline(kernelFile,line) )
    {
      istringstream strout(line);
      strout >> kernel_size;
    }
    kernel = new int[kernel_size];
  }
  kernel_II = kernel_size/(X*Y);
  kernelFile.close();
  int numRegisters,sched_t,max_schedule_time=0;
  kernelFile.open(argv[7], ifstream::in);
  if(kernelFile.is_open())
  {
    while ( getline(kernelFile,line) )
    {
      if(i<kernel_size)
      {
        istringstream strout(line);
        strout >> opID >> numRegisters >> sched_t;

        int t=getTime(i);
        int pe=getPE(i);

        if(opID != -1)
        {
          node_schedule_time[opID] = sched_t;

          max_schedule_time = (sched_t>max_schedule_time)?sched_t:max_schedule_time;
          earliest_sched_time = (sched_t < earliest_sched_time) ? sched_t : earliest_sched_time;

          if(schedule_time_nodes.count(sched_t) > 0)
          {

            std::set<int> operations = schedule_time_nodes[sched_t];
            operations.insert(opID);
            schedule_time_nodes[sched_t] = operations;
          }
          else
          {
            std::set<int> operations;
            operations.insert(opID);
            schedule_time_nodes[sched_t] = operations;
          }
        }
        std::pair<int,int> pe_t(pe,t);
        pe_time_Registers_map[pe_t] = numRegisters;
        kernel[i++] = opID;
      }
    }
  }
  kernelFile.close();

  //read the epilog file
  i=0;
  ifstream epilogFile (argv[8]);
  if(epilogFile.is_open())
  {
    while ( getline(epilogFile,line) )
    {
      istringstream strout(line);
      strout >> epilog_size;
    }
    epilog = new int[epilog_size];
  }
  epilogFile.close();
  epilogFile.open(argv[8], ifstream::in);
  if(epilogFile.is_open())
  {
    while ( getline(epilogFile,line) )
    {
      istringstream strout(line);
      strout >> opID;
      if(i<epilog_size)
        epilog[i++] = opID;
    }
  }
  epilogFile.close();

  ifstream LoopCtrlNodeFile("Control_Node.txt");
  if(LoopCtrlNodeFile.is_open()){
    FATAL(!getline(LoopCtrlNodeFile,line), "FATAL: Cannot read from Control_Node.txt file\n");
    istringstream strout(line);
    int temp;
    strout >> temp;
    if(!LCE_found) loopCtrl_node = temp; // No LCE edge
    else if(loopCtrl_node != temp) _FATAL("FATAL: Inconsistent loop control node detected\n");
  } else _FATAL("WARNING: Cannot open Control_Node.txt file\n");
    
  

  //POPULATE THE PROLOG, KERNEL and EPILOG related maps
  cout <<"\n"<< prolog_size << endl << kernel_size<<endl<<epilog_size<<endl;
  for(int j=0;j<prolog_size;j++)
  {
    if(prolog[j] != -1)
    {
      int pe,t,node;
      pe = getPE(j);
      node = prolog[j];
      t = getTime(j);
      std::pair<int,int> pe_time(pe,t);
      node_time_map_prolog.insert(std::pair<int,int>(node,t));
      prolog_map.insert(std::pair<int,int>(node,pe));
    }
  }

  int pecount=0;

  cout<<"*********KERNEL*****************\n";
  for(int j=0;j<kernel_size;j++)
  {
    if(kernel[j] != -1)
    {
      int pe,t,node;
      pe = getPE(j);
      node = kernel[j];
      t = getTime(j);
      std::pair<int,int> pe_time(pe,t);
      node_time_map_kernel.insert(std::pair<int,int>(node,t));
      kernel_map.insert(std::pair<int,int>(node,pe));
      pecount++;
    }
  }

  cout<<"*********EPILOG*****************\n";
  for(int j=0;j<epilog_size;j++)
  {
    if(epilog[j] != -1)
    {
      int pe,t,node;
      pe = getPE(j);
      node = epilog[j];
      t = getTime(j);
      std::pair<int,int> pe_time(pe,t);
      node_time_map_epilog.insert(std::pair<int,int>(node,t));
      epilog_map.insert(std::pair<int,int>(node,pe));
    }
  }

  readRegConfig();

  int totalPEs = X*Y;
  //initialize the free registers ma for each PE
  for(int i=0;i<totalPEs;++i)
  {
    std::set<int> freeRegs;
    for(int j=0;j<pe_reg_config[i];++j)
    {
      freeRegs.insert(j);
    }
    pe_free_registers[i] = freeRegs;
  }

  /* Make A Check In Case of No LiveStore, Generates Incorrectly 1 slot of NOOPS -> fixed Apr 2022 */
  int max_time = max_schedule_time + generateLiveVarStoreSchedule(max_schedule_time, livenodes);

  generateRegiConfigInstructions();
  generateINITinstructions(argv[5]);

  //Generate Instruction For Nodes Other Than Phi Nodes
  cout << "\n****** Generating Instructions For Non-Phi Nodes *****\n";
  for(int i=0; i<=max_schedule_time; ++i)
  {
    if(schedule_time_nodes.count(i) > 0)
    {
      std::set<int> nodesAtTime = schedule_time_nodes.find(i)->second;
      std::set<int>::iterator it;
      std::set<int> OtherThanPhiAtTime;
      for(it=nodesAtTime.begin(); it != nodesAtTime.end(); ++it)
      {
        if(getNodeType(*it) != cgra_select)
          OtherThanPhiAtTime.insert(*it);
      }
      cout<<"\nNODES SCHEDULED AT "<<i<<"\n";
      printSet(OtherThanPhiAtTime);
      generateInstructions(OtherThanPhiAtTime);
    }
  }

  cout << "\n****** Generating Instructions For Phi Nodes *****\n";
  //Generate Instruction For Nodes Other Than Phi Nodes
  for(int i=0; i<=max_schedule_time; ++i)
  {
    if(schedule_time_nodes.count(i) > 0)
    {
      std::set<int> nodesAtTime = schedule_time_nodes.find(i)->second;
      std::set<int>::iterator it;
      std::set<int> PhiAtTime;
      int phi_node_available = 0;
      for(it=nodesAtTime.begin(); it != nodesAtTime.end(); ++it)
      {
        if(getNodeType(*it) == cgra_select)
        {
          PhiAtTime.insert(*it);
          phi_node_available++;
        }
      }

      if(phi_node_available > 0)
      {
        cout<<"\nNODES SCHEDULED AT "<<i<<"\n";
        printSet(PhiAtTime);
        cout << "Phi Instructions" << endl;
        generatePhiInstructions(PhiAtTime);
        cout << "\nKernel Instructions" << endl;
        generateInstructions(PhiAtTime);
      }
    }
  }

  cout << "\n****** Generating Instructions For Store Nodes For Live Variables*****\n";
  int sched_time = max_schedule_time+1;

  for(i = sched_time; i<= max_time; i++)
  {
    if(schedule_time_nodes.count(i) > 0)
    {
      std::set<int> LiveNodesAtTime = schedule_time_nodes.find(i)->second;
      std::set<int>::iterator it;

      cout<<"\nNODES SCHEDULED AT "<<i<<"\n";
      cout<<"\nNODES SCHEDULED AT STORE CYCLE "<< (i-sched_time) <<"\n";
      printSet(LiveNodesAtTime);
      generateStoreInstructions(LiveNodesAtTime);
    }
  }


  // Added by Vinh TA
  // Algorithms are carried out here to construct iteration stages and adjust epilog, also generate versions of prolog.
  // A map from schedule time to a map of node_id to pe_num (sched_t to prolog/kernel/epilog map)
  std::map<int,std::vector<std::pair<int,int>>> iteration_map = construct_iteration_map();
  // A map from node_id to stage_id
  std::map<int,int> node_stage_map;
  std::map<int, std::set<int>> stage_cycle_map;
  std::tie(node_stage_map, stage_cycle_map)  = construct_stage_map(iteration_map);
  // Number of stages for an iteration
  int stage_count = -1;
  for(std::map<int,int>::iterator it = node_stage_map.begin(); it != node_stage_map.end(); ++it)
    if(it->second > stage_count) stage_count = it->second;
  
  cout << "Iteration schedule:";
  for(auto it = iteration_map.begin(); it != iteration_map.end(); ++it){
    cout << "\nTime: " << it->first << "\n";
    for(int i=0; i<it->second.size(); i++){
      cout << " " << it->second[i].first << "(" << it->second[i].second << ")(" << node_stage_map[it->second[i].first] << ")  - ";
    }
  } cout << endl;

  std::map<int,std::map<int,int>> prolog_version_phi_counter;
  int loopCtrl_stage, extend_cycle, array_size;
  
  if(!LCE_found) goto predicated_loop;  // No loopCtrl_node, skip adjustments
  
  // Stage at which loopCtrl node is scheduled
  loopCtrl_stage = node_stage_map[loopCtrl_node];
  cout << "Loop control node: " << loopCtrl_node << " - stage: " << loopCtrl_stage << " - exceeds: " << stage_count - loopCtrl_stage << endl;

  // Now modify epilog accordingly
  epilog_adjustment(iteration_map, node_stage_map, stage_cycle_map, loopCtrl_node);

  cout << "New epilog_size: " << epilog_size << " - adjusted epilog:\n";
  for(int i=0; i < (epilog_size/(X*Y)); i++){
    cout << "Time: " << i << endl;
    for(int x=0; x<X; x++){
      for(int y=0; y<Y; y++)
	cout << epilog[i*X*Y + x*X + y] << "\t";
      cout << endl;
    }
  }

 predicated_loop:
  // Generate versions of prolog
  int ** multi_prolog_mapping; // 2D array, 1 for version and 1 for mapping in a version
  //std::map<int,std::map<int,int>> prolog_version_phi_counter;
  int n_version;
  int version_cycle;
  tie(multi_prolog_mapping, prolog_version_phi_counter) = generate_prolog_versions(iteration_map, loopCtrl_node, &n_version, &version_cycle);
  array_size = sizeof(multi_prolog_mapping[0]); // - (final_livevar_store_size/(X*Y));
  cout << "Version cycle: " << version_cycle << endl;

  // Add livevar store inst to end of prolog cycles
  for(int i=0; i<n_version; i++)
    for(int j=0; j<final_livevar_store_size; j++){
      if(livevar_store[j] == -1) multi_prolog_mapping[i][(version_cycle*X*Y) + j] = -1;
      else multi_prolog_mapping[i][(version_cycle*X*Y) + j] = livevar_store[j];
    }

  cout << "\nProlog versions:\n";
  for(int i=0; i<n_version; i++){
    cout << "Version " << i << ":\n";
    for(int j=0; j<version_cycle; j++){
      cout << "Cycle " << j << endl;
      for(int x=0; x<X; x++){
	for(int y=0; y<Y; y++)
	  cout << multi_prolog_mapping[i][(j*X*Y) + x*X + y] << "\t";
	cout << endl;
      }
    }
    for(int j=0; j<final_livevar_store_size/(X*Y); j++){
      cout << "Store cycle: " << j << endl;
      for(int x=0; x<X; x++){
	for(int y=0; y<Y; y++)
	  cout << multi_prolog_mapping[i][version_cycle*X*Y + j*X*Y + x*X + y] << "\t";
	cout << endl;
      }
    }
  }
  cout << "Prolog version phi counter:\n";
  for(auto it = prolog_version_phi_counter.begin(); it != prolog_version_phi_counter.end(); ++it)
    for(auto itt = it->second.begin(); itt != it->second.end(); ++itt)
      cout << "Version: " << it->first << " - node: " << itt->first << " - counter: " << itt->second << endl;

  extend_cycle = n_version*(version_cycle + (final_livevar_store_size/(X*Y)));

  generateProlog(extend_cycle);
  extendProlog(multi_prolog_mapping, n_version, version_cycle, prolog_version_phi_counter); // add prolog nodes to final_prolog array
  modifyProlog(loopCtrl_node, n_version, (version_cycle + (final_livevar_store_size/(X*Y)))); // modify loopCtrl node to LE instruction
  generateKernel(loopCtrl_node);
  generateEpilog();

  dumpProlog(extend_cycle, n_version);
  dumpKernel();
  dumpEpilog();

  generateKernelCounter(max_schedule_time);
  return 0;

  /*predicated_loop:
  generateProlog(0);
  generateKernel(loopCtrl_node);
  generateEpilog();

  dumpProlog(0, 0);
  dumpKernel();
  dumpEpilog();

  generateKernelCounter(max_schedule_time);*/

  return 0;
}
